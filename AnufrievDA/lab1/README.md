# Практическая работа №1. Обработка изображений с использованием OpenCV

Этот проект представляет собой набор из восьми фильтров для обработки изображений, реализованных с использованием библиотеки OpenCV и NumPy. Ключевой особенностью является то, что большинство фильтров написано с использованием базовых операций над матрицами NumPy, а не высокоуровневых функций OpenCV, в соответствии с требованиями задания.

Скрипт позволяет применять выбранный фильтр к любому изображению через интерфейс командной строки.

## Структура проекта

*   `main.py`: Основной исполняемый файл. Отвечает за парсинг аргументов командной строки, загрузку изображения, вызов нужного фильтра и отображение результата.
*   `filters.py`: Файл-библиотека, содержащий реализации всех восьми функций-фильтров.
*   `assets/`: Директория с графическими ресурсами (рамки, блики, текстуры), которые используются некоторыми фильтрами.
*   `images/`: Директория для хранения тестовых изображений.

## Запуск и использование

Скрипт запускается из командной строки с двумя обязательными параметрами: названием фильтра и путем к изображению.

**Общий формат команды:**
```bash
python main.py <filter_name> <path_to_image> [optional_arguments]
```

**Пример:**
```bash
python main.py sepia images/test_image.jpg
```

Для некоторых фильтров доступны дополнительные параметры, которые можно посмотреть с помощью команды:
```bash
python main.py --help
```

---

## Описание алгоритмов фильтров

Ниже представлено описание алгоритмов, реализованных с использованием базовых операций.

### 1. Изменение разрешения (`resize`)
Фильтр изменяет размер изображения, реализуя алгоритм интерполяции **"ближайшего соседа" (Nearest-Neighbor)** с помощью базовых операций NumPy. Для каждого пикселя в новом изображении вычисляются соответствующие координаты в исходном, и цвет берется из ближайшего пикселя-оригинала. Это достигается путем создания массивов индексов и использования функции `np.take` для выбора нужных строк и столбцов. Этот метод является быстрым, но может приводить к потере качества по сравнению с более сложными алгоритмами.

### 2. Сепия (`sepia`)
Эффект сепии достигается путем прямого матричного умножения. BGR-вектор каждого пикселя умножается на специальную матрицу преобразования. Вместо высокоуровневой функции `cv2.transform`, используется оператор матричного умножения NumPy (`@`), что является базовой математической операцией. Результат обрезается до диапазона [0, 255] для корректного отображения.

### 3. Виньетка (`vignette`)
Эффект виньетирования реализуется путем создания маски затемнения "вручную" с помощью NumPy. Сначала создается координатная сетка для всего изображения. Затем для каждого пикселя вычисляется его евклидово расстояние до центра. Это расстояние нормализуется, и на его основе формируется маска, значения которой убывают от центра к краям. Итоговое изображение получается путем поэлементного умножения исходного изображения на эту маску.

### 4. Пикселизация (`pixelate`)
Алгоритм пикселизации состоит из трех шагов:
1.  **Выделение:** Из изображения вырезается заданная область (ROI).
2.  **Уменьшение:** ROI сжимается до маленького размера с помощью нашей собственной базовой функции `resize_image`.
3.  **Увеличение:** Уменьшенное изображение увеличивается обратно до исходного размера ROI, также с помощью `resize_image`. Так как наша функция реализует метод "ближайшего соседа", это создает характерный "блочный" эффект.

### 5. Простая рамка (`simple_frame`)
Этот фильтр добавляет простую одноцветную рамку. Реализация выполнена исключительно с помощью базовых операций над матрицами NumPy. Используя срезы, выбираются пиксели по краям изображения на заданную толщину, и им присваивается указанный BGR-цвет.

### 6. Фигурная рамка (`image_frame`)
Для наложения рамки используется PNG-файл с альфа-каналом. Рамка подгоняется под размер изображения с помощью нашей базовой функции `resize_image`. Затем извлекаются RGB и альфа-каналы. Итоговое изображение вычисляется путем ручного альфа-смешивания по формуле: `Результат = Рамка * Alpha + Изображение * (1 - Alpha)`, реализованного с помощью операций NumPy.

### 7. Блик объектива (`flare`)
Эффект блика накладывается из JPG-файла. Изображение блика масштабируется и позиционируется согласно параметрам с помощью нашей базовой функции `resize_image` и срезов NumPy. Смешивание реализовано "вручную" по формуле режима наложения "Screen": `Результат = 1 - (1 - Изображение) * (1 - Блик)`. Все вычисления производятся над NumPy-массивами с плавающей точкой.

### 8. Текстура бумаги (`paper`)
Фильтр накладывает текстуру бумаги. Вместо простой функции `cv2.addWeighted`, используется более сложный алгоритм:
1.  Текстура бумаги преобразуется в оттенки серого для создания маски.
2.  Эта маска определяет, в каких местах текстура будет "проступать" сильнее.
3.  Итоговое изображение вычисляется как линейная комбинация исходного изображения и текстуры, где веса для каждого пикселя определяются этой маской.