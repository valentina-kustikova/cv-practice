
```markdown
# Практическая работа №1. Обработка изображений с использованием OpenCV

Этот проект представляет собой набор из восьми фильтров для обработки изображений, реализованных с использованием библиотеки OpenCV и NumPy. Скрипт позволяет применять выбранный фильтр к любому изображению через интерфейс командной строки.

## Структура проекта

*   `main.py`: Основной исполняемый файл. Отвечает за парсинг аргументов командной строки, загрузку изображения, вызов нужного фильтра и отображение результата.
*   `filters.py`: Файл-библиотека, содержащий реализации всех восьми функций-фильтров.
*   `assets/`: Директория с графическими ресурсами (рамки, блики, текстуры), которые используются некоторыми фильтрами.
*   `images/`: Директория для хранения тестовых изображений.

## Запуск и использование

Скрипт запускается из командной строки с двумя обязательными параметрами: названием фильтра и путем к изображению.

**Общий формат команды:**
```bash
python main.py <filter_name> <path_to_image> [optional_arguments]
```

**Пример:**
```bash
python main.py sepia images/test_image.jpg
```

Для некоторых фильтров доступны дополнительные параметры, которые можно посмотреть с помощью команды:```bash
python main.py --help
```

---

## Описание алгоритмов фильтров

Ниже представлено краткое описание алгоритма реализации для каждого из восьми фильтров.

### 1. Изменение разрешения (`resize`)
Фильтр изменяет размер исходного изображения до заданных ширины и высоты. Для этого используется встроенная функция `cv2.resize()`. В качестве метода интерполяции выбран `cv2.INTER_AREA`, который является предпочтительным для уменьшения изображений, так как он предотвращает появление муара и дает качественный результат.

### 2. Сепия (`sepia`)
Этот фильтр имитирует эффект старой фотографии. Алгоритм основан на матричном преобразовании цветовых каналов. Для каждого пикселя его BGR-вектор умножается на специальную матрицу трансформации для получения сепии. Для эффективного выполнения этой операции над всем изображением используется функция `cv2.transform()`. После преобразования значения каналов, которые могли превысить 255, обрезаются до 255.

### 3. Виньетка (`vignette`)
Эффект виньетирования (затемнения углов) реализуется путем создания маски затемнения. Сначала генерируются два одномерных ядра Гаусса (для осей X и Y) с помощью `cv2.getGaussianKernel()`. Их внешнее произведение дает двумерную Гауссову маску, значения которой максимальны в центре и плавно убывают к краям. Эта маска нормализуется до диапазона [0, 1] и поэлементно умножается на каждый цветовой канал исходного изображения, что и приводит к затемнению углов.

### 4. Пикселизация (`pixelate`)
Алгоритм пикселизации выбранной прямоугольной области состоит из трех шагов:
1.  **Выделение:** Из исходного изображения вырезается заданная область (Region of Interest, ROI).
2.  **Уменьшение:** ROI сжимается до очень маленького размера (например, в 20 раз меньше по каждой оси) с использованием интерполяции `cv2.INTER_NEAREST`.
3.  **Увеличение:** Маленькое изображение увеличивается обратно до исходного размера ROI, также с методом `cv2.INTER_NEAREST`. Этот метод не сглаживает пиксели, а дублирует их, что создает характерный "блочный" эффект.
Обработанная область вставляется обратно в изображение.

### 5. Простая рамка (`simple_frame`)
Этот фильтр добавляет простую одноцветную рамку. Реализация выполнена с помощью базовых операций над матрицами NumPy. Используя срезы, выбираются пиксели по краям изображения (верхние, нижние, левые и правые строки/столбцы) на заданную толщину, и им присваивается указанный BGR-цвет.

### 6. Фигурная рамка (`image_frame`)
Для наложения декоративной рамки используется внешний PNG-файл с альфа-каналом (прозрачностью). Алгоритм следующий:
1.  Изображение рамки загружается с помощью `cv2.IMREAD_UNCHANGED` и подгоняется под размер основного изображения.
2.  Из рамки извлекаются RGB-каналы и альфа-канал. Альфа-канал нормализуется до диапазона [0, 1].
3.  Итоговое изображение вычисляется по формуле альфа-смешивания: `Результат = Рамка * Alpha + Изображение * (1 - Alpha)`. Это позволяет плавно наложить рамку поверх исходного фото.

### 7. Блик объектива (`flare`)
Этот эффект имитирует блик от источника света и накладывается из внешнего JPG-файла (обычно блик на черном фоне).
1.  Изображение блика загружается, масштабируется и позиционируется согласно параметрам пользователя.
2.  Для смешивания используется режим наложения "Screen" (Экран). Математически он вычисляется как `Результат = 1 - (1 - Изображение) * (1 - Блик)`. Этот режим делает черные участки блика полностью прозрачными, а светлые — осветляют исходное изображение, создавая реалистичный эффект.

### 8. Текстура бумаги (`paper`)
Фильтр накладывает текстуру бумаги для имитации рисунка.
1.  Внешний JPG-файл с текстурой загружается и подгоняется под размер основного изображения.
2.  Итоговый эффект достигается путем взвешенного сложения (линейной интерполяции) исходного изображения и изображения текстуры с помощью функции `cv2.addWeighted()`. Параметр `strength` (сила) определяет пропорцию, в которой смешиваются изображения, позволяя регулировать заметность текстуры.

```