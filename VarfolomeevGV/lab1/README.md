# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Краткое описание

Проект реализует библиотеку фильтров на Python с применением базовых операций OpenCV над матрицами изображений. Все фильтры ожидают на вход цветные (трёхканальные) изображения и оформлены статическими методами класса `ImageFilter` (файл `image_filters/filters.py`). В реализации присутствует GUI на PyQt5 (`image_filters/gui.py`), демонстрирующий работу фильтров и облегчающий настройку параметров.

## Структура проекта

```
.
├── image_filters/
│   ├── __init__.py      # инициализация пакета
│   ├── filters.py       # базовые фильтры и утилиты работы с текстурами
│   └── gui.py           # PyQt5 интерфейс (опционально для демонстрации)
├── main.py              # точка входа, запускает GUI
└── README.md            # описание проекта и алгоритмов
```

## Установка зависимостей

Проект тестировался с Python 3.10+, OpenCV 4.8+, NumPy 1.24+, PyQt5 5.15+.

```bash
pip install -r requirements.txt
```

## Запуск демонстрации

```bash
python main.py
```

## Описание реализованных фильтров

### 1. Интерполяция NN (Nearest Neighbour interpolation)
- На вход подаётся изображение и коэффициент масштабирования.
- Выполняется прямой двойной цикл по всем координатам.
- Для каждого пикселя новой матрицы вычисляются координаты ближайшего старого пикселя через деление на масштаб и `floor`.
- Результат возвращается в отдельном массиве.

### 2. Билленейная интерполяция
- Масштабирование выполняется векторным способом с использованием `np.linspace`.
- Формируется сетка координат, для каждого пикселя находятся четыре ближайших исходных значения.
- Рассчитываются веса по осям X/Y
```python
    ...
    dy = (y_coords - y0).reshape(new_height, 1, 1).astype(np.float32)
    dx = (x_coords - x0).reshape(1, new_width, 1).astype(np.float32)
    ...
```
- Линейная комбинация значений по горизонтали 
```python
    ...
    top = top_left * (1.0 - dx) + top_right * dx
    bottom = bottom_left * (1.0 - dx) + bottom_right * dx
    ...
```
- Линейная комбинация top и bottom по вертикали
```
    ...
    interpolated = top * (1.0 - dy) + bottom * dy
    ...
```
- Результат приводится к `uint8` и готов к дальнейшей обработке.

### 3. Линейное изменение разрешения (Linear Resize)
- Реализует равномерное растяжение массива пикселей без интерполяции.
- Координаты новых пикселей получаются через `np.linspace`, после чего используется fancy-indexing `image[np.ix_(...)]`.
- Метод полезен для демонстрации различий между интерполяцией и простым повторением пикселей.

### 4. Sepia
- Матрица преобразования
  ```python
  [[0.272, 0.534, 0.131],
   [0.349, 0.686, 0.168],
   [0.393, 0.769, 0.189]]
  ```
  перемножается с матрицей изображения, чтобы получить фильтр сепии на оригинальном изображении.
- Результат обрезается `np.clip(..., 0, 255)` и приводится к типу `uint8`.

### 5. Vignette
- Центр виньетки задаётся пользователем или вычисляется как центр изображения; координаты ограничиваются границами изображения.
- Построение маски выполняется через `np.indices`, расстояния нормализуются относительно максимального расстояния до углов.
- Формула ослабления: `mask = 1.0 - intensity * (distance / max_radius)`, затем маска ограничивается на отрезке `[0,1]`.

### 6. Pixelation 
- Пользователь задаёт координаты и размеры области.
- Координаты приводятся к целым значениям, 
- Регион разбивается на сетку блоков: в двух вложенных циклах вычисляется среднее значение по каждому блоку (`pixel_size × pixel_size`), тем самым формируется “уменьшенное” изображение.
- Ещё двумя вложенными циклами средние значения блоков разворачиваются обратно до исходного размера, создавая эффект крупных пикселей без использования `cv2.resize`.
- Обработанный блок вставляется обратно в копию исходного изображения.

### 7. Frame (simple)
- Создаёт прямоугольную рамку указанной толщины и цвета.
- Толщина приводится к диапазону `[0, 255]`; значение `0` означает отсутствие рамки.
- Цвет, вводимый как `(R, G, B)`, нормализуется по модулю 256 и переставляется в `(B, G, R)`.
- Копия изображения подкрашивается вручную: верхняя и нижняя полосы (`frame_width` строк), а также левая и правая полосы (`frame_width` столбцов) заполняются заданным цветом. Используются срезы NumPy.

### 8. Frame (curvy)
- По умолчанию рисует волнистую рамку (`frame_type="wave"`): для каждой стороны вычисляется синусоидальное смещение.
- Контуры строятся массивами точек и рисуются через `cv2.polylines`.
- Цвет обрабатывается аналогично простому варианту (RGB → BGR).
- При активированной опции внешней рамки используется общий метод наложения `apply_overlay`, который масштабирует PNG с альфа-каналом к размеру кадра через собственный линейный ресайз и накладывает его поверх изображения.

### 9. Glare (блики объектива)
- Базовый режим строит радиальную маску, создавая белый блик вокруг центра.
- Пользователь может выбрать центр кликом по изображению, задать радиус и интенсивность.
- Процедурный вариант использует маску `mask = (1 - dist/radius)^2`, умноженную на интенсивность; результат суммируется с исходником и обрезается до `[0,255]`.
- Если загружена текстура PNG с альфа-каналом, вызывается `apply_overlay_centered`: текстура приводится к BGRA, при необходимости масштабируется встроенным линейным ресайзом и накладывается без растягивания по центру (или выбранной точке), при этом альфа умножается на коэффициент интенсивности.

### 10. Watercolor Paper Texture
- Сначала исходник сглаживается двусторонним фильтром (`cv2.bilateralFilter`).
- Внешняя текстура приводится к размеру изображения с помощью `apply_linear_resize`; если альфа отсутствует, она вычисляется из яркости.
- Карта прозрачности рассчитывается как `alpha_map = alpha * intensity`, при цветном изображении добавляется ось каналов.
- Итог вычисляется формулой `smooth * (1 - alpha_map) + texture * alpha_map`.
- Без текстуры фильтр не запускается: пользователь получает уведомление о необходимости загрузить PNG.

### 11. Overlay (альфа-композитинг)
- Универсальный метод для наложения изображений, учитывающий наличие альфа-канала.
- Если размеры отличаются, внешний слой масштабируется собственной функцией линейного ресайза.
- Альфа-канал нормализуется в диапазон `[0,1]`, смешивание выполняется по формуле `overlay * alpha + base * (1 - alpha)`.
- Для RGBA-изображений пересчитывается результирующий альфа-канал: `overlay_alpha + (1 - overlay_alpha) * base_alpha`.

## Особенности графического интерфейса
- Отображение исходного и обработанного кадра, гистограммы каналов с независимыми чекбоксами R/G/B.
- Динамическая панель параметров: слайдеры синхронизированы со спинбоксами, параметры валидируются.
- Поддержка выбора координат мышью (центр блика, виньетки, прямоугольник для пикселизации).
- Внешние текстуры отображаются миниатюрой; кнопка автоматически меняет подписи («Load Frame», «Load Glare» и т.д.).
- Результат можно сохранить или открыть во внешнем просмотрщике; временные копии пишутся в `%temp%`.

## Соответствие требованиям задания

| Требование | Реализация |
|-----------|------------|
| Функция изменения разрешения | `apply_Nearest_Neighbor_interpolation`, `apply_Bilinear_interpolation`, а также `apply_linear_resize` как дополнительный вариант |
| Сепия | `apply_sepia` |
| Виньетка | `apply_vignette` |
| Пикселизация области | `apply_pixelation` |
| Прямоугольная рамка | `apply_frame_simple` |
| Фигурная рамка | `apply_frame_curvy` (с поддержкой внешних текстур)|
| Блики | `apply_glare` (с поддержкой внешних текстур) |
| Текстура акварельной бумаги | `apply_watercolor_texture` (только внешние текстуры)|
| README с описанием алгоритмов | текущий документ |
| Демонстрация работы | `main.py` + GUI загружает изображение, позволяет выбрать фильтр, применяет и показывает результат и доп. информацию|

