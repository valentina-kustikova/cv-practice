## Практическая работа №1.Обработка изображений с использованием библиотеки OpenCV

---

## 1. Изменение размера изображения (класс ResizeImage)
Изменяет размер изображения с сохранением пропорций или указанными размерами.

**Параметры:**

- image: Входное изображение (NumPy массив в формате BGR)     
- scale (float, опционально): Коэффициент масштабирования    
- height (int, опционально): Желаемая высота изображения    
- width (int, опционально): Желаемая ширина изображения    

**Алгоритм:**

1)Если указан коэффициент масштабирования, вычисляются новые размеры умножением исходных размеров на коэффициент       
2)Если указаны и высота и ширина, используются указанные значения        
3)Если параметры не указаны, возвращается исходное изображение       
4)Выбирается метод интерполяции:      
        INTER_AREA - для уменьшения размера    
        INTER_CUBIC - для увеличения размера    
        INTER_LINEAR - по умолчанию    
5)Применяется функция cv.resize() с выбранной интерполяцией     

**Пример использования.**

python main.py -i image.jpg -f resize --scale 0.5 -o smaall.jpg    
python main.py -i image.jpg -f resize --new_size 800 600 -o resize.jpg    
python main.py -i image.jpg -f resize --scale 2 -o big.jpg    
python main.py -i image.jpg -f resize -o image.jpg    

## 2. Эффект сепии (класс SepiaFilter)
Применяет к изображению эффект сепии (желтоватый оттенок, характерный для старых фотографий).

**Параметры:**

- image: Входное изображение (NumPy массив)    
- intensity (float, опционально): Интенсивность эффекта (по умолчанию 1.0)    

**Алгоритм:**

1)Создается матрица преобразования сепии с предопределенными коэффициентами     
2)Матрица смешивается с единичной матрицей для регулировки интенсивности:     
    При intensity ≤ 1.0: линейная комбинация матриц    
    При intensity > 1.0: усиление с последующей нормализацией    
3)Применяется матричное преобразование cv.transform()    
4)Значения ограничиваются диапазоном [0, 255]    

**Пример использования.**

python main.py -i image.jpg -f sepia -o sepia.jpg    
python main.py -i image.jpg -f sepia --k 0.5 -o light_sepia.jpg    

## 3. Эффект виньетки (класс VignetteFilter)
Создает эффект затемнения по краям изображения (виньетка).

**Параметры:**

- image: Входное изображение (NumPy массив)     
- strength (float, опционально): Сила эффекта затемнения (по умолчанию 0.5)     

**Алгоритм:**

1)Вычисляется центр изображения     
2)Создается координатная сетка с помощью np.ogrid     
3)Рассчитывается расстояние от каждого пикселя до центра     
4)Создается гауссова маска затемнения:    
    Центр изображения остается ярким    
    Яркость уменьшается к краям по экспоненциальному закону    
5)Маска применяется к каждому цветовому каналу изображения    
6)Значения ограничиваются диапазоном [0, 255]    

**Математическая формула:**

mask = exp(-((x - center_x)² / (2*(width*strength)²) + (y - center_y)² / (2*(height*strength)²)))    

**Пример использования.**

python main.py -i image.jpg -f vinetka -o vignette.jpg    
python main.py -i image.jpg -f vinetka --radius 0.8 -o strong_vignette.jpg     

## 4. Пикселизация области (класс PixelateFilter)
Пикселизирует указанную область изображения, создавая эффект мозаики.

**Параметры:**

- image: Входное изображение (NumPy массив)     
- block_size (int, опционально): Размер блока пикселизации (по умолчанию 10)     
- x, y (int, опционально): Координаты левого верхнего угла области    
- width, height (int, опционально): Размеры области для пикселизации    

**Алгоритм:**

1)Если координаты и размеры не указаны, обрабатывается все изображение    
2)Проверяются и корректируются границы области    
3)Вычисляются фактические размеры области    
4)Область уменьшается до малого размера с линейной интерполяцией    
5)Уменьшенная область увеличивается обратно с интерполяцией NEAREST    
6)Результат вставляется обратно в исходное изображение    

**Пример использования.**

python main.py -i image.jpg -f pixelize --k 20 -o pixelated.jpg     
python main.py -i image.jpg -f pixelize --pixel_x 150 --pixel_y 20 --pixel_w 300 --pixel_h 300 --k 15 -o area_pixel.jpg     

## 5. Прямоугольная рамка (класс RectBorder)
Добавляет прямоугольную рамку заданной толщины и цвета по краям изображения.

**Параметры:**

- image: Входное изображение (NumPy массив)    
- border_width (int, опционально): Толщина рамки в пикселях (по умолчанию 10)    
- color (tuple, опционально): Цвет рамки в формате BGR (по умолчанию (255, 255, 0) - желтый)    

**Алгоритм:**

1)Толщина рамки ограничивается половиной меньшего размера изображения    
2)Заполняются пиксели по всем четырем сторонам:     
    Верхняя граница: [0:border_width, :]     
    Нижняя граница: [-border_width:, :]    
    Левая граница: [:, 0:border_width]    
    Правая граница: [:, -border_width:]    

**Пример использования.**

python main.py -i image.jpg -f rect_frame -o bordered.jpg     
python main.py -i image.jpg -f rect_frame --thickness 25 --color 0 0 255 -o red_border.jpg     

## 6. Фигурная рамка (класс FrameFilter)
Добавляет декоративную рамку различных геометрических форм вокруг изображения.

**Параметры:**

- image: Входное изображение (NumPy массив)     
- frame_type (str, опционально): Тип рамки: 'circle', 'diamond', 'rectangle' (по умолчанию 'circle')     
- border_width (int, опционально): Толщина рамки (по умолчанию 10)     
- color (tuple, опционально): Цвет рамки в формате BGR (по умолчанию (255, 255, 0))     

**Алгоритм:**

Круглая рамка: Рисуется окружность с центром в середине изображения    
Ромбовидная рамка: Создается полилиния из 4 точек (середины сторон)     
Прямоугольная рамка: Заполняются края изображения (аналогично RectBorder)     

**Пример использования.**

python main.py -i image.jpg -f frame -o circle_frame.jpg     
python main.py -i image.jpg -f frame --frame_type diamond -o diamond_frame.jpg    
python main.py -i image.jpg -f frame --frame_type diamond --thickness 15 --color 0 255 0 -o diamond_frame.jpg    

## 7. Эффект бликов объектива (класс BliksFilter)
Имитирует эффект бликов объектива камеры.

**Параметры:**

- image: Входное изображение (NumPy массив)     
- intensity (float, опционально): Интенсивность бликов (по умолчанию 0.5)     
- cx, cy (int, опционально): Координаты центра бликов     

**Алгоритм:**

1)Если координаты центра не указаны, используется центр изображения    
2)Создается координатная сетка с помощью np.ogrid     
3)Рассчитывается расстояние от каждого пикселя до центра бликов     
4)Создается маска бликов по экспоненциальному закону     
5)Маска применяется ко всем цветовым каналам     
6)Блики добавляются к исходному изображению     

**Математическая формула:**

flare = exp(-2 * distance / max_distance) * intensity     

**Пример использования.**

python main.py -i image.jpg -f bliki -o flare.jpg     
python main.py -i image.jpg -f bliki --cx 300 --cy 200 --k 0.8 -o custom_flare.jpg     
python main.py -i image.jpg -f bliki --cx 300 --cy 200 --k 0.8 -o custom_flare.jpg     

## 8. Текстура акварельной бумаги (класс WatercolorFilter)
Накладывает текстуру, имитирующую акварельную бумагу.

**Параметры:**

- image: Входное изображение (NumPy массив)    
- intensity (float, опционально): Интенсивность текстуры (по умолчанию 0.2)     

**Алгоритм:**

1)Генерируется случайный шум с равномерным распределением    
2)Шум размывается гауссовым фильтром для создания мягкой текстуры     
3)Текстура смешивается с исходным изображением с заданной интенсивностью     
4)Используется взвешенная сумма: result = image*(1-intensity) + texture*intensity     

**Пример использования.**

python main.py -i image.jpg -f watercolor -o watercolor.jpg    
python main.py -i image.jpg -f watercolor --k 0.5 -o strong_watercolor.jpg    
