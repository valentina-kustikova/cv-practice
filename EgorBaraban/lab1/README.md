# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Реализованные функции

`Все функции возвращают матрицу (H, W, 3) - картинку с форматом цветов b,g,r`

***1. `resize(img, new_h, new_w, sigma)`***

- Переводит картинку во float32 для вычислений
- Cчитает масштабы `new_h/H` и `new_w/W` (`sigma` - для построения 1д ядра гаусса)
- При даунскейлинге использует фильтр Гаусса (1d, два прохода по y и по x), чтобы избавиться от алиасов при редкой выборке
- Строит координатные сетки для dest и переводит их в координаты sourca с полуцентровым выравниванием
- Использует билинейную интерполяцию (использует 4 соседних пикселя с весами) Поэтому работает быстро / +- качественно

(В своей реализации задействует функции `gaussian_kernel1d` и `convolve_separable`)


***2. `sepia_filter(img, intensity)`***

- Накладывает эффект сепии к изображению с заданной интенсивностью
- Просто смешивает каналы исходника по заранее известной формуле, получая full_sepia
- После чего используя интесивность создает результат
`(1 - intensity) * img + intensity * full_sepia`


***3. `vignette(img, intensity, radius)`***

- Для каждого пикселя считает расстояние до центра, нормирует деля `rmax`, потом клипает от 0 до 1
- Строит маску, скалирует ее в зависимости от интенсивности и применяет поканально


***4. `pixelate(img, left_top, right_bot, pixel_size=10)`***

- принимает картинку и два кортежа, первый - координаты левой верхней точки, второй - координаты правой нижней точки области, которую нужно пиксилизировать (в формате `(y,x)` оба )

- принимает размер пикселя - на этот кооэффициент будет даунскейлиться изображение. После чего будет приводиться к старым размерам и вставляться в `img`


***5. `add_rect_frame(img, w, color)`***

- `color` в формате bgr
- меняет все каналы на bgr в первых и последних строках и столбцах `w` матрицы

***6. `add_figure_frame(img, f_index, t=50.0)`***

- Берет, и все "небелые" области фото с рамкой переносит на `img`
- считает `color_diff = ‖frame−255‖₂`, после чего маску `mask = diff > t`, где t - порог чувствительности

***7. `add_glare(image, strength=0.85)`***

- накладывает блик с картинки `glare_cool.png` 
- результат получается как комбинация `1 - (1 - A) (1 - B)`
, где `A` - нормализованная картинка (цвет / 255), `B` - нормализованный блик
- если просто использовать img + k*glare, то часто уходит в потолок 255
- усиливает блик в темных местах. Если взять $d/d(glare)$ то получим $1 - img$, т.е. чем темнее пиксель, тем заметнее добавленный свет

***8. `add_watercolor_texture(image, intensity=0.3)`***

- накладывает текстуру акварельной бумаги таким образом, чтобы "неровности" ощущались сильнее
- считает маску `m` (вес этой "фактуры" в точке) как ` 1 - нормированное среднее по каналам для каждого пикселя tex`
- добавляет канал, чтобы забродкастилось 1 -> b, g, r
- использует интенсивность для получения результата

## Как работать с программой    

Необходимо запускать с командной строки в таком формате:

`python main.py --show --image <PATH> OPERATION [FLAGS] [--output <OUT_PATH>]
`

если путь не указан, добавляет в папку `out` в директории с `main.py`

Примеры запусков:

`python main.py --show --image ./images/img_1.jpg  resize --height 480 --width 640`

`python main.py --show --image ./images/img_1.jpg sepia_filter --intensity 0.6`

`python main.py --show --image ./images/img_1.jpg vignette --intensity 0.8 --radius 250`

`python main.py --show --image ./images/img_1.jpg pixelate --y1 20 --x1 300 --y2 280 --x2 520 --block 10`

`python main.py --image ./images/img_1.jpg --show add_rect_frame --thickness 40 --b 0 --g 128 --r 255`

`python main.py --show --image ./images/img_1.jpg add_figure_frame --index 2 --threshold 50`


`python main.py --show --image ./images/img_1.jpg add_glare --strength 0.8`

`python main.py --show --image ./images/img_1.jpg add_watercolor_texture --intensity 0.35`
