
# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание проекта

Библиотека фильтров для обработки изображений с помощью базовых операций над матрицами в OpenCV и NumPy. Все фильтры реализованы вручную, без использования высокоуровневых функций OpenCV.

## Установка и запуск

**Требования:**
- Python 3.x
- opencv-python
- numpy

**Установка зависимостей:**
```bash
pip install opencv-python numpy
```

**Запуск программы:**
```bash
python script.py <путь_к_изображению> <тип_фильтра> [--params ...]
```

## Описание фильтров и алгоритмы

### 1. Изменение разрешения изображения

**Входные параметры:**
- изображение
- желаемая ширина (`width`)
- желаемая высота (`height`)
- коэффициент масштабирования (`scale`)

**Алгоритм:**
Процесс состоит из двух ключевых этапов:
1. Определение выходных размеров (`W'` `x` `H'`): Логика выбора новых размеров реализована со следующими приоритетами:
* По коэффициенту масштабирования (`scale`): `W' = W * scale`, `H' = H * scale`.
* По явным размерам (`width` и `height`): `W' = width`, `H' = height`.
* Только по ширине (`width`): Высота вычисляется с сохранением пропорций: `H' = H * (width / W)`.
* Только по высоте (`height`): Ширина вычисляется с сохранением пропорций: `W' = W * (height / H)`.
2. Заполнение пикселей (`Интерполяция методом ближайшего соседа`): Для всей сетки пикселей нового изображения вычисляются соответствующие координаты в исходном. Затем, используя продвинутую индексацию NumPy, новое изображение целиком заполняется значениями из исходного, что является полностью векторизованной операцией.

**Математическая формула:**
`P_new(x', y') = P_old(floor(x' * W/W'), floor(y' * H/H'))`

**Примеры запуска:**
```bash
python script.py photo.jpg resize --params 800 600
python script.py photo.jpg resize --params scale 0.5
```

---

### 2. Фотоэффект сепии

**Входные параметры:**
- изображение

**Алгоритм:**
Эффект достигается путем линейного преобразования цветового пространства. Все пиксели изображения (представленные как матрица (`H`, `W`, `3`)) умножаются на матрицу преобразования сепии. Операция `np.dot` выполняет это для всего изображения за один вызов.

**Формула:**
```bash
[B']   [0.272  0.534  0.131]   [B]
[G'] = [0.349  0.686  0.168] * [G]
[R']   [0.393  0.769  0.189]   [R]
```

**Пример запуска:**
```bash
python script.py photo.jpg sepia
```

---

### 3. Фотоэффект виньетки

**Входные параметры:**
- изображение
- интенсивность эффекта (от 0 до 1, по умолчанию 0.5)

**Алгоритм:**
Создается 2D-маска, интенсивность которой зависит от радиального расстояния до центра. Эта маска применяется ко всем трем цветовым каналам изображения одновременно с помощью механизма трансляции (`broadcasting`) NumPy, что исключает необходимость в циклах.

**Формула:**
```bash
Для нормализованных координат (X, Y) в [-1, 1]:
Mask(X, Y) = 1 - strength * (X² + Y²)
Image_new = Image_old * Mask
```

**Пример запуска:**
```bash
python script.py photo.jpg vignette --params 0.7
```

---

### 4. Пикселизация области

**Входные параметры:**
- изображение
- размер блока пикселизации (по умолчанию 10, задается в коде)

**Алгоритм:**
1. Выделенная пользователем область изображения уменьшается в размере до количества пиксельных блоков (например, область 100x100 с блоком 10 сжимается до 10x10) с использованием интерполяции `INTER_NEAREST`.
2. Затем полученное маленькое изображение увеличивается обратно до исходного размера области, также с интерполяцией `INTER_NEAREST`. В результате каждый пиксель маленького изображения становится большим цветным блоком.

**Пример запуска:**
```bash
python script.py photo.jpg pixelate
```
(Область выбирается мышью в появившемся окне, для применения фильтра после выделения области необходимо нажать `Enter`)

---

### 5. Прямоугольная одноцветная рамка

**Входные параметры:**
- изображение
- цвет рамки (B G R)
- ширина рамки

**Алгоритм:**
С помощью срезовой индексации `NumPy` выбираются пиксели по краям изображения (верхние, нижние, левые и правые строки/столбцы) на заданную толщину. Затем этим срезам присваивается указанный цвет рамки.

**Пример запуска:**
```bash
python script.py photo.jpg rect_border --params 255 0 0 20
```

---

### 6. Фигурная одноцветная рамка

**Входные параметры:**
- изображение
- цвет рамки (B G R)
- ширина рамки
- тип фигуры (например, circle, star, wave)

**Алгоритм:**
Создается пустая одноканальная маска размером с изображение. На ней с помощью функции `cv2.fillPoly` рисуется белая фигура (круг, звезда, волна), определяющая внутреннюю область. Затем все пиксели исходного изображения, соответствующие черным областям маски, закрашиваются цветом рамки.

**Формула (для рамки 'wave'):**
Координаты точек контура вычисляются по синусоиде. Для плавности в углах амплитуда A умножается на коэффициент затухания.
```bash
y(x) = thickness + A * sin(ω_x * x)
```

**Примеры запуска:**
```bash
python script.py photo.jpg shape_border --params 0 255 0 15 circle
python script.py photo.jpg shape_border --params 255 255 0 10 star
python script.py oleg.jpg shape_border --params 0 0 255 10 wave
```

---

### 7. Эффект бликов объектива

**Входные параметры:**
- изображение
- x-координата центра блика
- y-координата центра блика
- интенсивность (от 0 до 1)

**Алгоритм:**
Эффект моделируется путем наложения нескольких радиальных градиентов. Для всего изображения вычисляется расстояние каждого пикселя до центра блика. На основе этого расстояния создается маска интенсивности, которая добавляется к пикселям изображения. Аналогично создаются и добавляются несколько меньших цветных артефактов.

**Формула:**
Интенсивность `S` блика для пикселя на расстоянии `d `от центра:
```bash
S(d) = intensity * (1 - d / R)
```

**Пример запуска:**
```bash
python script.py photo.jpg lens_flare --params 400 150 0.7
```
(400 — x-координата центра блика, 150 — y-координата, 0.7 — интенсивность)

---

### 8. Текстура акварельной бумаги

**Входные параметры:**
- изображение
- сила наложения текстуры (от 0 до 1)

**Алгоритм:**
Генерируется 2D-массив случайного `Гауссовского шума`, который затем размывается для получения плавной текстуры. Итоговое изображение получается путем линейной интерполяции между исходным изображением и массивом шума.

**Формула:**
```bash
I_new = (1 - α) * I_orig + α * I_noise
```
Где `α` (альфа) — это `strength`, сила наложения текстуры.

**Пример запуска:**
```bash
python script.py photo.jpg watercolor --params 0.3
```

---

## Особенности реализации

- Все фильтры реализованы только через базовые операции NumPy и OpenCV.
- Для пикселизации реализован интерактивный выбор области мышью.
- Окно вывода всегда показывает оригинал и результат рядом для наглядного сравнения.
