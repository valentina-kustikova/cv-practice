Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV
Описание проекта
Библиотека фильтров для обработки изображений на Python с использованием OpenCV и NumPy. Программа реализует 8 различных фильтров с простым консольным интерфейсом.

Требования
Python 3.6+

OpenCV (opencv-python)

NumPy

Matplotlib (для отображения всех фильтров)

Установка
bash
pip install opencv-python numpy matplotlib
Использование
Запуск программы
bash
python image_filters.py
Необходимые файлы
Основное изображение: image.jpg (если нет - создается тестовое)

Текстура рамки: border.png (если нет - создается простая)

Текстура блика: flare.png (если нет - создается простая)

Меню программы
text
1. Изменение разрешения
2. Эффект сепии
3. Виньетка
4. Пикселизация области
5. Рамка из PNG
6. Блик из PNG
7. Акварельная текстура
8. Показать все фильтры
0. Выход
Описание фильтров и алгоритмов
1. Изменение разрешения
Алгоритм: Линейная интерполяция

python
new_width = int(width * scale_factor)
new_height = int(height * scale_factor)
resized = cv2.resize(image, (new_width, new_height), interpolation=cv2.INTER_LINEAR)
Принцип работы: Вычисляет новые размеры и масштабирует изображение с линейной интерполяцией для сглаживания.

2. Эффект сепии
Алгоритм: Матричное преобразование цветов

python
sepia_filter = np.array([
    [0.393, 0.769, 0.189],
    [0.349, 0.686, 0.168],
    [0.272, 0.534, 0.131]
])
Принцип работы: Применяет матрицу преобразования к каждому пикселю, создавая коричневатый оттенок старых фотографий.

3. Эффект виньетки
Алгоритм: Гауссова маска затемнения

python
kernel_x = cv2.getGaussianKernel(width, width/3)
kernel_y = cv2.getGaussianKernel(height, height/3)
kernel = kernel_y * kernel_x.T
mask = 1 - (1 - mask) * strength
Принцип работы: Создает гауссов градиент от центра к краям и умножает на него изображение.

4. Пикселизация области
Алгоритм: Двухэтапное масштабирование

python
# Уменьшаем
small = cv2.resize(region, (small_width, small_height), interpolation=cv2.INTER_LINEAR)
# Увеличиваем обратно
pixelated = cv2.resize(small, (width, height), interpolation=cv2.INTER_NEAREST)
Принцип работы: Выделенная область уменьшается, затем увеличивается до исходного размера без сглаживания.

5. Рамка из PNG
Алгоритм: Альфа-смешивание

python
result = border_rgb * alpha + image * (1 - alpha)
Принцип работы: PNG-рамка накладывается с учетом альфа-канала (прозрачности).

6. Блик из PNG
Алгоритм: Наложение с прозрачностью

python
for each pixel:
    result = flare_color * alpha + image_color * (1 - alpha)
Принцип работы: PNG-текстура блика накладывается в указанной позиции с учетом прозрачности.

7. Акварельная текстура
Алгоритм: Добавление шума + размытие

python
noise = np.random.normal(0, 15, image.shape)
textured = image + noise
blurred = cv2.GaussianBlur(textured, (3, 3), 0)
Принцип работы: Добавляет случайный шум и применяет легкое размытие для имитации бумажной текстуры.

8. Показать все фильтры
Алгоритм: Пакетная обработка

python
fig, axes = plt.subplots(3, 3, figsize=(15, 12))
for i, (img, title) in enumerate(results):
    axes[i].imshow(img)
Принцип работы: Применяет все фильтры последовательно и отображает результаты в сетке 3×3.