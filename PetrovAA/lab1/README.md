# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание алгоритмов реализации каждого фильтра

### 1. Функция изменения разрешения изображения
**Алгоритм:** 
- Получаем исходные размеры изображения (высоту и ширину) через `image.shape[:2]`
- Умножаем размеры на коэффициент масштабирования `scale_factor`
- Используем функцию `cv2.resize()` с билинейной интерполяцией `INTER_LINEAR` для плавного изменения размера
- Возвращаем изображение с новыми размерами

**Математическая основа:** Линейная интерполяция пикселей при изменении размеров изображения.

### 2. Функция применения фотоэффекта сепии к изображению
**Алгоритм:**
- Создаем матрицу преобразования сепии 3×3 с коэффициентами для RGB каналов
- Применяем линейное преобразование с помощью `cv2.transform()`
- Ограничиваем значения пикселей диапазоном [0, 255] с помощью `np.clip()`
- Преобразуем результат обратно в тип `uint8`

**Математическая основа:** 
R_new = 0.393 * R + 0.769 * G + 0.189 * B
G_new = 0.349 * R + 0.686 * G + 0.168 * B
B_new = 0.272 * R + 0.534 * G + 0.131 * B

### 3. Функция применения фотоэффекта виньетки к изображению
**Алгоритм:**
- Создаем двумерное гауссово распределение с помощью `cv2.getGaussianKernel()`
- Нормализуем маску к диапазону [0, 1]
- Применяем силу эффекта виньетки через параметр `strength`
- Умножаем каждый цветовой канал изображения на маску

**Математическая основа:** Гауссова функция для создания плавного затемнения от центра к краям.

### 4. Функция пикселизации заданной прямоугольной области изображения
**Алгоритм:**
- Проверяем границы области и корректируем при выходе за пределы изображения
- Выделяем указанную прямоугольную область
- Уменьшаем разрешение области в `pixel_size` раз с линейной интерполяцией
- Увеличиваем разрешение обратно до исходного размера с nearest-neighbor интерполяцией
- Заменяем исходную область на пикселизированную версию

**Математическая основа:** Двойное преобразование размера с разными типами интерполяции для создания блочного эффекта.

### 5. Функция наложения прямоугольной одноцветной рамки заданной ширины по краям изображения
**Алгоритм:**
- Используем `cv2.copyMakeBorder()` с параметром `BORDER_CONSTANT`
- Задаем ширину рамки и цвет в формате RGB
- Функция автоматически добавляет рамку указанного цвета по всем краям изображения

**Математическая основа:** Расширение матрицы изображения с заполнением постоянными значениями.

### 6. Функция наложения фигурной одноцветной рамки по краям изображения
**Алгоритм:**
- Реализованы два типа фигурных рамок: пунктирная и точечная
- Для пунктирной рамки: рисуем короткие отрезки с промежутками по всем границам
- Для точечной рамки: рисуем точки с равными интервалами по границам
- Изменяем пиксели непосредственно в пограничных областях изображения

**Математическая основа:** Дискретное рисование геометрических примитивов по границам матрицы.

### 7. Функция наложения эффекта бликов объектива камеры
**Алгоритм:**
- Если позиция не указана, размещаем блик в центре изображения
- Создаем гауссово распределение яркости вокруг указанной позиции
- Используем формулу гауссова распределения для создания плавного блика
- Усиливаем эффект умножением на коэффициент 150
- Добавляем полученный блик к исходному изображению

**Математическая основа:** Двумерная гауссова функция:
flare = exp(-(dx² + dy²) / (2 * size²))

### 8. Функция наложения текстуры акварельной бумаги
**Алгоритм:**
- Генерируем шум с нормальным распределением для имитации текстуры бумаги
- Создаем трехканальный шум с одинаковыми значениями для RGB
- Добавляем шум к исходному изображению
- Применяем легкое гауссово размытие для создания "акварельного" эффекта