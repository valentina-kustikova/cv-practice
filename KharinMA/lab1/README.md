# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание
Библиотека фильтров для обработки изображений с использованием только базовых операций OpenCV (без применения высокоуровневых функций обработки изображений).

## Структура проекта
- `filters.py` - библиотека с реализацией всех фильтров
- `main.py` - демонстрационный скрипт для работы с фильтрами
- `README.md` - описание алгоритмов и инструкция по использованию

## Установка зависимостей
```bash
pip install -r requirements.txt
```

## Использование

### Демонстрация всех фильтров
```bash
python main.py <путь_к_изображению>
```

### Применение отдельного фильтра
```bash
python main.py <путь_к_изображению> <название_фильтра> [параметры]
```

### Примеры
```bash
# Показать все фильтры
python main.py test_image.jpg

# 1. Изменить размер изображения (масштабирование)
python main.py test_image.jpg resize --scale 0.5

# 2. Изменить размер изображения (конкретная ширина)
python main.py test_image.jpg resize --width 800

# 3. Применить эффект сепии
python main.py test_image.jpg sepia --intensity 0.8

# 4. Добавить виньетку
python main.py test_image.jpg vignette --strength 0.7

# 5. Пикселизировать область
python main.py test_image.jpg pixelate --x 100 --y 100 --width 300 --height 300 --pixel_size 20

# 6. Добавить простую рамку
python main.py test_image.jpg simple_frame --frame_width 30

# 7. Добавить фигурную рамку (волны)
python main.py test_image.jpg decorative_frame --pattern waves --frame_width 40

# 8. Добавить фигурную рамку (зигзаг)
python main.py test_image.jpg decorative_frame --pattern zigzag --frame_width 35

# 9. Добавить эффект бликов объектива
python main.py test_image.jpg lens_flare --intensity 0.8

# 10. Добавить текстуру акварельной бумаги
python main.py test_image.jpg watercolor --intensity 0.6
```

---

## Описание алгоритмов реализации фильтров

### 1. Функция изменения разрешения изображения (`resize_image`)

**Алгоритм:**
1. Получаем размеры исходного изображения (высоту `h` и ширину `w`)
2. Вычисляем новые размеры на основе входных параметров:
   - Если задан коэффициент масштабирования `scale`, умножаем текущие размеры на него
   - Если заданы конкретные ширина и/или высота, используем их (с сохранением пропорций при необходимости)
3. Создаем новое пустое изображение с вычисленными размерами
4. Применяем **метод ближайшего соседа** с использованием векторизации NumPy:
   - Создаем массивы индексов `y_ratio` и `x_ratio` с помощью `np.linspace`, которые равномерно распределяют индексы исходного изображения
   - Используем `np.meshgrid` для создания двумерных сеток индексов
   - Применяем индексацию массива NumPy для выборки пикселей из исходного изображения
5. Возвращаем изображение с новым разрешением

**Используемые базовые операции:**
- Создание массива NumPy (`np.zeros`)
- Функция `np.linspace` для создания равномерно распределенных значений
- Функция `np.meshgrid` для создания координатных сеток
- Индексация массива NumPy
- Преобразование типов данных

---

### 2. Функция применения фотоэффекта сепии (`apply_sepia`)

**Алгоритм:**
1. Преобразуем исходное изображение в формат `float32` для точных вычислений.
2. Определяем **матрицу преобразования цветов** (3x3) с коэффициентами для каналов (B, G, R).
3. Выполняем **матричное умножение** (`@`) исходного изображения на транспонированную матрицу сепии. Это позволяет пересчитать цвета всех пикселей одновременно без использования циклов.
4. Ограничиваем полученные значения диапазоном [0, 255] с помощью `np.clip`.
5. Смешиваем результат с исходным изображением (линейная интерполяция) в зависимости от параметра `intensity`:
   - `result = original × (1 - intensity) + sepia × intensity`
6. Преобразуем результат обратно в `uint8`.

**Используемые методы и оптимизации:**
- Матричное умножение (`@` / `np.matmul`) для быстрой обработки каналов.
- Транспонирование матрицы (`.T`).
- Ограничение значений (`np.clip`).
- Векторизованная арифметика NumPy.

---

### 3. Функция применения фотоэффекта виньетки (`apply_vignette`)

**Алгоритм:**
1. Получаем размеры изображения и вычисляем координаты центра.
2. Считаем максимальное евклидово расстояние от центра до угла (для нормализации).
3. Генерируем координатные векторы осей Y и X с помощью `np.ogrid` (память выделяется только для векторов, а не для полной сетки).
4. Используя механизм **broadcasting** (расширения массивов), вычисляем карту расстояний от каждого пикселя до центра.
5. Вычисляем карту коэффициентов затемнения:
   - `vignette_factor = 1 - (normalized_distance × strength)`
6. Убираем отрицательные значения с помощью `np.maximum` (защита от пересвета при высокой силе эффекта).
7. Добавляем дополнительную размерность (`np.newaxis`) к карте коэффициентов, чтобы применить её ко всем трем цветовым каналам одновременно.
8. Умножаем изображение на карту коэффициентов и возвращаем результат в `uint8`.

**Используемые методы и оптимизации:**
- `np.ogrid` для экономного создания координатных осей.
- Broadcasting (автоматическое расширение размерностей при арифметике).
- `np.maximum` для пороговой фильтрации.
- `np.newaxis` для согласования размерностей маски и изображения.

---

### 4. Функция пикселизации заданной прямоугольной области (`pixelate_region`)

**Алгоритм:**
1. Создаем копию исходного изображения
2. Определяем границы области для пикселизации с учетом границ изображения
3. Разбиваем область на блоки размером `pixel_size × pixel_size`:
   - Проходим по области с шагом `pixel_size` по обеим осям
   - Для каждого блока:
     - Определяем границы блока (с учетом краев области)
     - Извлекаем пиксели блока
     - Вычисляем **средний цвет** блока: `avg_color = mean(block_pixels)`
     - Заполняем весь блок вычисленным средним цветом
4. Возвращаем изображение с пикселизированной областью

**Используемые базовые операции:**
- Копирование массива
- Срезы массива (slicing)
- Функция `np.mean()` для вычисления среднего значения
- Функция `min()` для ограничения индексов
- Присваивание значений диапазону элементов

---

### 5. Функция наложения прямоугольной одноцветной рамки (`add_simple_frame`)

**Алгоритм:**
1. Создаем копию исходного изображения
2. Получаем размеры изображения (высоту `h` и ширину `w`)
3. Заполняем краевые области заданным цветом:
   - Верхняя полоса: `image[0:frame_width, :] = color`
   - Нижняя полоса: `image[h-frame_width:h, :] = color`
   - Левая полоса: `image[:, 0:frame_width] = color`
   - Правая полоса: `image[:, w-frame_width:w] = color`
4. Возвращаем изображение с рамкой

**Используемые базовые операции:**
- Копирование массива
- Срезы массива для работы с диапазонами пикселей
- Присваивание значений диапазону элементов

---

### 6. Функция наложения фигурной одноцветной рамки (`add_decorative_frame`)

**Алгоритм:**
1. Создаем копию исходного изображения
2. Получаем размеры изображения
3. В зависимости от выбранного паттерна (`pattern`) применяем различные узоры:

   **Паттерн "waves" (волны):**
   - Для каждого пикселя вычисляем волновое смещение: `offset = 5 × sin(coordinate × 0.1)`
   - Для верхней/нижней границы используем `x` как переменную синуса
   - Для левой/правой границы используем `y` как переменную синуса
   - Если пиксель находится в пределах `frame_width + offset` от края, окрашиваем его

   **Паттерн "zigzag" (зигзаг):**
   - Вычисляем зигзагообразное смещение: `offset = |((coordinate % 40) - 20)|`
   - Это создает пилообразную функцию с периодом 40 пикселей
   - Применяем аналогично волнам, но с зигзагообразной функцией

4. Возвращаем изображение с фигурной рамкой

**Используемые базовые операции:**
- Копирование массива
- Тригонометрические функции (`np.sin`, `np.cos`)
- Арифметические операции
- Условные операторы
- Операция остатка от деления (`%`)

---

### 7. Функция наложения эффекта бликов объектива камеры (`add_lens_flare`)

**Алгоритм:**
1. Получаем размеры изображения (высоту `h` и ширину `w`)
2. Определяем путь к файлу текстуры блика `blik.png` в текущей директории
3. Проверяем существование файла текстуры:
   - Если файл не найден, выводим предупреждение и возвращаем исходное изображение
4. Загружаем текстуру блика с поддержкой альфа-канала:
   - Используем флаг `cv2.IMREAD_UNCHANGED` для загрузки с альфа-каналом
   - Если загрузка не удалась, выводим предупреждение и возвращаем исходное изображение
5. Масштабируем текстуру под размер изображения:
   - `cv2.resize(blik, (w, h), interpolation=cv2.INTER_LINEAR)`
6. Проверяем наличие альфа-канала (4 канала):
   - **Если есть альфа-канал:**
     - Извлекаем альфа-канал и нормализуем: `alpha = blik[:, :, 3] / 255.0`
     - Извлекаем RGB каналы текстуры
     - Применяем **альфа-композитинг** для каждого канала:
       - `result[c] = original[c] × (1 - alpha × intensity) + texture[c] × (alpha × intensity)`
   - **Если альфа-канала нет:**
     - Применяем простое линейное смешивание:
       - `result = original × (1 - intensity) + texture × intensity`
7. Ограничиваем значения диапазоном [0, 255] с помощью `np.clip`
8. Преобразуем результат в `uint8` и возвращаем

**Используемые базовые операции:**
- Функция `cv2.imread()` для загрузки текстуры
- Функция `cv2.resize()` для масштабирования текстуры
- Извлечение каналов массива по индексам
- Арифметические операции для смешивания
- Функция `np.clip()` для ограничения значений
- Преобразование типов данных

**Примечание:** Для работы фильтра требуется файл `blik.png` в директории со скриптом.

---

### 8. Функция наложения текстуры акварельной бумаги (`add_watercolor_texture`)

**Алгоритм:**
1. Определяем путь к файлу текстуры бумаги `paper.png` в текущей директории
2. Проверяем существование файла текстуры:
   - Если файл не найден, выводим предупреждение и возвращаем исходное изображение
3. Загружаем текстуру акварельной бумаги:
   - Используем `cv2.imread()` для загрузки изображения текстуры
   - Если загрузка не удалась, выводим предупреждение и возвращаем исходное изображение
4. Получаем размеры исходного изображения (высоту `h` и ширину `w`)
5. Масштабируем текстуру под размер изображения:
   - `cv2.resize(paper_texture, (w, h), interpolation=cv2.INTER_LINEAR)`
6. Преобразуем оба изображения в `float32` для точных вычислений:
   - `result = image.astype(np.float32)`
   - `paper_float = paper_resized.astype(np.float32)`
7. Применяем **аддитивное смешивание** (сложение) текстуры с изображением:
   - `result = result + paper_float × intensity`
   - Текстура добавляется к изображению, создавая эффект наложения бумаги
8. Ограничиваем значения диапазоном [0, 255]:
   - `result = np.clip(result, 0, 255)`
9. Преобразуем результат обратно в `uint8` и возвращаем

**Используемые базовые операции:**
- Функция `cv2.imread()` для загрузки текстуры
- Функция `cv2.resize()` для масштабирования текстуры
- Преобразование типов данных (`astype()`)
- Арифметические операции (сложение и умножение массивов)
- Функция `np.clip()` для ограничения значений

**Примечание:** Для работы фильтра требуется файл `paper.png` в директории со скриптом.

