# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание
Библиотека фильтров для обработки изображений с использованием только базовых операций OpenCV (без применения высокоуровневых функций обработки изображений).

## Структура проекта
- `filters.py` - библиотека с реализацией всех фильтров
- `main.py` - демонстрационный скрипт для работы с фильтрами
- `README.md` - описание алгоритмов и инструкция по использованию

## Установка зависимостей
```bash
pip install -r requirements.txt
```

## Использование

### Демонстрация всех фильтров
```bash
python main.py <путь_к_изображению>
```

### Применение отдельного фильтра
```bash
python main.py <путь_к_изображению> <название_фильтра> [параметры]
```

### Примеры
```bash
# Показать все фильтры
python main.py test_image.jpg

# Применить эффект сепии
python main.py test_image.jpg sepia --intensity 0.8

# Изменить размер изображения
python main.py test_image.jpg resize --scale 0.5

# Добавить виньетку
python main.py test_image.jpg vignette --strength 0.7

# Добавить фигурную рамку
python main.py test_image.jpg decorative_frame --pattern waves --frame_width 40
```

---

## Описание алгоритмов реализации фильтров

### 1. Функция изменения разрешения изображения (`resize_image`)

**Алгоритм:**
1. Получаем размеры исходного изображения (высоту и ширину)
2. Вычисляем новые размеры на основе входных параметров:
   - Если задан коэффициент масштабирования `scale`, умножаем текущие размеры на него
   - Если заданы конкретные ширина и/или высота, используем их (с сохранением пропорций при необходимости)
3. Создаем новое пустое изображение с вычисленными размерами
4. Применяем **билинейную интерполяцию**:
   - Для каждого пикселя нового изображения вычисляем соответствующую позицию в исходном изображении
   - Находим 4 соседних пикселя в исходном изображении
   - Вычисляем веса для интерполяции на основе дробных частей координат
   - Интерполируем значение цвета как взвешенную сумму 4 соседних пикселей
5. Возвращаем изображение с новым разрешением

**Используемые базовые операции:**
- Создание массива NumPy (`np.zeros`)
- Обращение к элементам массива по индексам
- Арифметические операции

---

### 2. Функция применения фотоэффекта сепии (`apply_sepia`)

**Алгоритм:**
1. Создаем копию исходного изображения и преобразуем в `float32` для точных вычислений
2. Для каждого пикселя изображения:
   - Извлекаем значения каналов B, G, R
   - Применяем **матрицу преобразования сепии**:
     - `new_R = 0.393 × R + 0.769 × G + 0.189 × B`
     - `new_G = 0.349 × R + 0.686 × G + 0.168 × B`
     - `new_B = 0.272 × R + 0.534 × G + 0.131 × B`
   - Ограничиваем значения диапазоном [0, 255]
   - Смешиваем результат с исходным цветом с учетом параметра `intensity`:
     - `final_color = original_color × (1 - intensity) + sepia_color × intensity`
3. Преобразуем результат обратно в `uint8`
4. Возвращаем изображение с эффектом сепии

**Используемые базовые операции:**
- Копирование массива (`np.copy`)
- Преобразование типов данных
- Покомпонентные арифметические операции
- Функция `min()` для ограничения значений

---

### 3. Функция применения фотоэффекта виньетки (`apply_vignette`)

**Алгоритм:**
1. Получаем размеры изображения (высоту и ширину)
2. Вычисляем центр изображения: `(center_x, center_y) = (width/2, height/2)`
3. Вычисляем максимальное расстояние от центра до угла: `max_distance = √(center_x² + center_y²)`
4. Создаем маску виньетки:
   - Для каждого пикселя вычисляем расстояние до центра: `distance = √((x - center_x)² + (y - center_y)²)`
   - Нормализуем расстояние: `normalized_distance = distance / max_distance`
   - Вычисляем коэффициент затемнения: `mask_value = 1 - (normalized_distance × strength)`
5. Применяем маску к каждому каналу изображения:
   - `result_channel = original_channel × mask_value`
6. Ограничиваем значения диапазоном [0, 255] и преобразуем в `uint8`
7. Возвращаем изображение с эффектом виньетки

**Используемые базовые операции:**
- Вычисление квадратного корня (`np.sqrt`)
- Создание массива (`np.zeros`)
- Умножение массивов
- Обращение к элементам по индексам

---

### 4. Функция пикселизации заданной прямоугольной области (`pixelate_region`)

**Алгоритм:**
1. Создаем копию исходного изображения
2. Определяем границы области для пикселизации с учетом границ изображения
3. Разбиваем область на блоки размером `pixel_size × pixel_size`:
   - Проходим по области с шагом `pixel_size` по обеим осям
   - Для каждого блока:
     - Определяем границы блока (с учетом краев области)
     - Извлекаем пиксели блока
     - Вычисляем **средний цвет** блока: `avg_color = mean(block_pixels)`
     - Заполняем весь блок вычисленным средним цветом
4. Возвращаем изображение с пикселизированной областью

**Используемые базовые операции:**
- Копирование массива
- Срезы массива (slicing)
- Функция `np.mean()` для вычисления среднего значения
- Функция `min()` для ограничения индексов
- Присваивание значений диапазону элементов

---

### 5. Функция наложения прямоугольной одноцветной рамки (`add_simple_frame`)

**Алгоритм:**
1. Создаем копию исходного изображения
2. Получаем размеры изображения (высоту `h` и ширину `w`)
3. Заполняем краевые области заданным цветом:
   - Верхняя полоса: `image[0:frame_width, :] = color`
   - Нижняя полоса: `image[h-frame_width:h, :] = color`
   - Левая полоса: `image[:, 0:frame_width] = color`
   - Правая полоса: `image[:, w-frame_width:w] = color`
4. Возвращаем изображение с рамкой

**Используемые базовые операции:**
- Копирование массива
- Срезы массива для работы с диапазонами пикселей
- Присваивание значений диапазону элементов

---

### 6. Функция наложения фигурной одноцветной рамки (`add_decorative_frame`)

**Алгоритм:**
1. Создаем копию исходного изображения
2. Получаем размеры изображения
3. В зависимости от выбранного паттерна (`pattern`) применяем различные узоры:

   **Паттерн "waves" (волны):**
   - Для каждого пикселя вычисляем волновое смещение: `offset = 5 × sin(coordinate × 0.1)`
   - Для верхней/нижней границы используем `x` как переменную синуса
   - Для левой/правой границы используем `y` как переменную синуса
   - Если пиксель находится в пределах `frame_width + offset` от края, окрашиваем его

   **Паттерн "zigzag" (зигзаг):**
   - Вычисляем зигзагообразное смещение: `offset = |((coordinate % 40) - 20)|`
   - Это создает пилообразную функцию с периодом 40 пикселей
   - Применяем аналогично волнам, но с зигзагообразной функцией

4. Возвращаем изображение с фигурной рамкой

**Используемые базовые операции:**
- Копирование массива
- Тригонометрические функции (`np.sin`, `np.cos`)
- Арифметические операции
- Условные операторы
- Операция остатка от деления (`%`)

---

### 7. Функция наложения эффекта бликов объектива камеры (`add_lens_flare`)

**Алгоритм:**
1. Получаем размеры изображения (высоту `h` и ширину `w`)
2. Определяем путь к файлу текстуры блика `blik.png` в текущей директории
3. Проверяем существование файла текстуры:
   - Если файл не найден, выводим предупреждение и возвращаем исходное изображение
4. Загружаем текстуру блика с поддержкой альфа-канала:
   - Используем флаг `cv2.IMREAD_UNCHANGED` для загрузки с альфа-каналом
   - Если загрузка не удалась, выводим предупреждение и возвращаем исходное изображение
5. Масштабируем текстуру под размер изображения:
   - `cv2.resize(blik, (w, h), interpolation=cv2.INTER_LINEAR)`
6. Проверяем наличие альфа-канала (4 канала):
   - **Если есть альфа-канал:**
     - Извлекаем альфа-канал и нормализуем: `alpha = blik[:, :, 3] / 255.0`
     - Извлекаем RGB каналы текстуры
     - Применяем **альфа-композитинг** для каждого канала:
       - `result[c] = original[c] × (1 - alpha × intensity) + texture[c] × (alpha × intensity)`
   - **Если альфа-канала нет:**
     - Применяем простое линейное смешивание:
       - `result = original × (1 - intensity) + texture × intensity`
7. Ограничиваем значения диапазоном [0, 255] с помощью `np.clip`
8. Преобразуем результат в `uint8` и возвращаем

**Используемые базовые операции:**
- Функция `cv2.imread()` для загрузки текстуры
- Функция `cv2.resize()` для масштабирования текстуры
- Извлечение каналов массива по индексам
- Арифметические операции для смешивания
- Функция `np.clip()` для ограничения значений
- Преобразование типов данных

**Примечание:** Для работы фильтра требуется файл `blik.png` в директории со скриптом.

---

### 8. Функция наложения текстуры акварельной бумаги (`add_watercolor_texture`)

**Алгоритм:**
1. Определяем путь к файлу текстуры бумаги `paper.png` в текущей директории
2. Проверяем существование файла текстуры:
   - Если файл не найден, выводим предупреждение и возвращаем исходное изображение
3. Загружаем текстуру акварельной бумаги:
   - Используем `cv2.imread()` для загрузки изображения текстуры
   - Если загрузка не удалась, выводим предупреждение и возвращаем исходное изображение
4. Получаем размеры исходного изображения (высоту `h` и ширину `w`)
5. Масштабируем текстуру под размер изображения:
   - `cv2.resize(paper_texture, (w, h), interpolation=cv2.INTER_LINEAR)`
6. Преобразуем оба изображения в `float32` для точных вычислений:
   - `result = image.astype(np.float32)`
   - `paper_float = paper_resized.astype(np.float32)`
7. Применяем **аддитивное смешивание** (сложение) текстуры с изображением:
   - `result = result + paper_float × intensity`
   - Текстура добавляется к изображению, создавая эффект наложения бумаги
8. Ограничиваем значения диапазоном [0, 255]:
   - `result = np.clip(result, 0, 255)`
9. Преобразуем результат обратно в `uint8` и возвращаем

**Используемые базовые операции:**
- Функция `cv2.imread()` для загрузки текстуры
- Функция `cv2.resize()` для масштабирования текстуры
- Преобразование типов данных (`astype()`)
- Арифметические операции (сложение и умножение массивов)
- Функция `np.clip()` для ограничения значений

**Примечание:** Для работы фильтра требуется файл `paper.png` в директории со скриптом.

