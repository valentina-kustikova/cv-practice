# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV
---

## 1. Функция `resize_image(image_path, width, height, scale)`

**Масштабирует изображение с загрузкой из файла** 

**Вход:** 

 - image_path — исходное изображение
 - width, height — новая ширина и высота в пикселях
 - scale — коэффициент масштабирования (вместо указания размеров)

 **Алгоритм работы:**

Сначала загружается изображение. 
 - Если задан scale, размеры пересчитываются пропорционально;
 - Если указаны width и/или height, вычисляются пропорциональные размеры.
Формируются индексы пикселей src_i и src_j с помощью целочисленного деления координат.
Новый массив создаётся поэлементным копированием пикселей через индексацию.

---

## 2. Функция `apply_sepia(image, intensity)`

**Применяет фильтр сепия к изображению** 

**Вход:** 

 - image — исходное изображение
 - intensity — интенсивность эффекта (0.0-2.0)

 **Алгоритм работы:**

Создается матрица сепии sepia_matrix преобразования цветов. Каждый пиксель умножается на матрицу через np.dot(). Если интенсивность < 1, результат смешивается с оригиналом через взвешенную сумму. Значения ограничиваются диапазоном [0, 255].

---

## 3. Функция `apply_vignette(image, intensity)`

**Создает эффект виньетки к изображению** 

**Вход:** 

 - image — исходное изображение
 - intensity — интенсивность эффекта (0.0-1.0)

 **Алгоритм работы:**

 Вычисляется расстояние от каждого пикселя до центра изображения. Создается маска с эллиптическим затуханием от центра к краям. Каждый канал изображения умножается на маску для создания эффекта затемнения.


 ---

 ## 4. Функция `apply_pixelation(image, x, y, width, height, pixel_size)`

 **Пикселизирует заданную прямоугольную область** 

**Вход:** 

 - image — исходное изображение
 - x, y — координаты левого верхнего угла области
 - width, height — размеры области для пикселизации
 - pixel_size — размер пикселя эффекта

 **Алгоритм работы:**

 Выделяется прямоугольная область изображения. Область уменьшается в pixel_size раз через manual_resize(). Уменьшенная область увеличивается обратно до исходного размера. Область заменяется в исходном изображении.

 ---

 ## 5. Функция `apply_frame(image, frame_width, frame_color)`

  **Добавляет прямоугольную рамку вокруг изображения** 

**Вход:** 

 - image — исходное изображение
 - frame_width — ширина рамки в пикселях
 - frame_color — цвет рамки (в формате BGR)

 **Алгоритм работы:**

 Создается новое изображение большего размера (height + 2*frame_width). Новое изображение заполняется цветом рамки через np.full(). Исходное изображение вставляется в центр через индексацию.

 ---

 ## 6. Функция apply_figure_frame(image, frame_path)

 **Накладывает фигурную рамку из файла** 

**Вход:** 

 - image — исходное изображение
 - frame_path — путь к файлу с фигурной рамкой

 **Алгоритм работы:**

 Загружается изображение рамки и масштабируется под размер исходного. Для каждого пикселя вычисляется яркость и создается альфа-маска. Белые области (яркость > 0.9) становятся прозрачными, цветные — непрозрачными. Выполняется альфа-смешивание рамки с исходным изображением.

 ---
 ## 7. Функция apply_lens_flare(image, flare_path, intensity, position, blend_mode)

 **Добавляет эффект бликов объектива** 

**Вход:** 

 - image — исходное изображение
 - flare_path — путь к файлу с бликом
 - intensity — интенсивность эффекта
 - position — позиция блика на изображении

 **Алгоритм работы:**

 Загружается изображение блика и создается альфа-маска из его яркости. Блик позиционируется на изображении (по умолчанию — правый верхний угол). Применяется выбранный режим смешивания (screen/add/lighten) с учетом альфа-канала. Черные области блика становятся прозрачными

 ---

 ## 8. Функция watercolor_texture(image, intensity, strength)

 **Накладывает текстуру акварельной бумаги** 

**Вход:** 

 - image — исходное изображение
 - intensity — интенсивность текстуры
 - strength — сила текстуры (регулирует контраст)

 **Алгоритм работы:**

 Загружается текстура бумаги по фиксированному пути. Текстура масштабируется под размер исходного изображения. Создается маска из инвертированной яркости текстуры. Маска преобразуется степенной функцией для регулировки контраста. Выполняется смешивание изображения с текстурой через маск. 