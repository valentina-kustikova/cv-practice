# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание

Данная работа представляет собой библиотеку фильтров для обработки изображений, реализованную с использованием базовых операций над матрицами в OpenCV. Все функции реализованы без использования высокоуровневых функций обработки изображений библиотеки OpenCV.

## Реализованные функции

### 1. Функция изменения разрешения изображения (`change_resolution`)

**Алгоритм реализации:**

Функция изменяет разрешение изображения путем масштабирования с использованием индексации массивов NumPy.

1. Получаем текущие размеры изображения (высота и ширина).
2. Вычисляем новые размеры на основе переданных параметров:
   - Если задана только ширина, высота вычисляется пропорционально.
   - Если задана только высота, ширина вычисляется пропорционально.
   - Если заданы оба параметра, используются они.
3. Создаем массивы индексов для нового изображения:
   - Для каждого пикселя нового изображения вычисляется соответствующий пиксель исходного изображения по формуле: `индекс_нового * (размер_старого / размер_нового)`.
4. Используем индексацию массивов NumPy для выборки пикселей из исходного изображения: `image[y_indices[:, None], x_indices[None, :]]`.
5. Ограничиваем индексы диапазоном допустимых значений с помощью `np.clip`.

**Параметры:**
- `image` - исходное изображение
- `new_width` - новая ширина (опционально)
- `new_height` - новая высота (опционально)

---

### 2. Функция применения фотоэффекта сепии (`apply_sepia`)

**Алгоритм реализации:**

Эффект сепии достигается путем применения цветовой матрицы преобразования к каждому пикселю изображения.

1. Определяем матрицу преобразования сепии (3x3), которая задает веса для каналов RGB:
   ```
   [[0.393, 0.769, 0.189],
    [0.349, 0.686, 0.168],
    [0.272, 0.534, 0.131]]
   ```
2. Преобразуем изображение в тип `float` для точных вычислений.
3. Применяем матричное умножение: `np.dot(image, sepia_filter.T)` - умножаем каждый пиксель на транспонированную матрицу фильтра.
4. Ограничиваем значения результата диапазоном [0, 255] с помощью `np.clip`.
5. Преобразуем результат обратно в тип `uint8`.

**Параметры:**
- `image` - исходное изображение

---

### 3. Функция применения фотоэффекта виньетки (`apply_vignette`)

**Алгоритм реализации:**

Виньетка создает эффект затемнения по краям изображения, имитируя эффект объектива камеры.

1. Получаем размеры изображения (высота и ширина).
2. Создаем координатные сетки для всех пикселей с помощью `np.meshgrid`.
3. Вычисляем центр изображения: `(width // 2, height // 2)`.
4. Для каждого пикселя вычисляем расстояние до центра по формуле: `sqrt((X - center_x)² + (Y - center_y)²)`.
5. Вычисляем максимальное расстояние от центра до угла изображения.
6. Создаем фактор виньетки: `1 - (расстояние / максимальное_расстояние) * strength`.
   - В центре фактор близок к 1 (яркость сохраняется).
   - На краях фактор близок к 0 (затемнение).
7. Ограничиваем фактор диапазоном [0, 1].
8. Применяем фактор к каждому каналу изображения: `image * vignette_factor`.
9. Преобразуем результат обратно в тип `uint8`.

**Параметры:**
- `image` - исходное изображение
- `strength` - сила эффекта виньетки (по умолчанию 0.8)

---

### 4. Функция пикселизации заданной прямоугольной области изображения (`pixelate_region`)

**Алгоритм реализации:**

Пикселизация разбивает выбранную область на блоки и заменяет каждый блок средним цветом пикселей в этом блоке.

1. Создаем интерактивный интерфейс для выбора области:
   - Используется callback-функция для обработки событий мыши.
   - Пользователь перетаскивает мышь для выбора прямоугольной области.
2. После подтверждения выбора (клавиша SPACE):
   - Определяем границы выбранной области (минимальные и максимальные координаты).
   - Разбиваем область на блоки размером `pixel_size` (10 пикселей).
3. Для каждого блока:
   - Извлекаем пиксели блока из исходного изображения.
   - Вычисляем средний цвет блока по всем каналам: `np.mean(block, axis=(0, 1))`.
   - Заменяем все пиксели блока на вычисленный средний цвет.
4. Возвращаем изображение с пикселизированной областью.

**Параметры:**
- `image` - исходное изображение

---

### 5. Функция наложения прямоугольной одноцветной рамки (`add_solid_border`)

**Алгоритм реализации:**

Функция добавляет одноцветную рамку заданной ширины по краям изображения.

1. Получаем размеры исходного изображения.
2. Создаем новое изображение большего размера:
   - Новая высота: `height + 2 * border_width`
   - Новая ширина: `width + 2 * border_width`
3. Инициализируем новое изображение цветом рамки: заполняем весь массив значением `border_color`.
4. Копируем исходное изображение в центр нового изображения:
   - Позиция: `[border_width:border_width + height, border_width:border_width + width]`

**Параметры:**
- `image` - исходное изображение
- `border_width` - ширина рамки в пикселях (по умолчанию 10)
- `border_color` - цвет рамки в формате BGR (по умолчанию белый)

---

### 6. Функция наложения фигурной одноцветной рамки (`add_patterned_border`)

**Алгоритм реализации:**

Функция добавляет фигурную рамку с различными узорами по краям изображения.

1. Создаем изображение с увеличенными размерами (аналогично одноцветной рамке).
2. Копируем исходное изображение в центр.
3. Создаем координатные сетки для всего изображения с помощью `np.ogrid`.
4. Определяем маску границ: пиксели, которые находятся в области рамки (в пределах `border_width` от краев).
5. В зависимости от типа узора (`pattern_type`):
   - **"zigzag"**: Создаем зигзагообразный узор на основе условия `(X + Y) % 10 < 5` - чередование пикселей по диагонали.
   - **"dots"**: Создаем точечный узор на основе условия `(X % 10 == 0) & (Y % 10 == 0)` - точки на пересечении сетки.
   - **"waves"**: Создаем волнообразный узор на основе синусоидальной функции `(np.sin(X * 0.1) + np.sin(Y * 0.1)) > 0`.
6. Применяем узор только к области рамки: `bordered_image[mask & border_mask] = border_color`.

**Параметры:**
- `image` - исходное изображение
- `border_width` - ширина рамки в пикселях (по умолчанию 20)
- `border_color` - цвет рамки в формате BGR (по умолчанию белый)
- `pattern_type` - тип узора: "zigzag", "dots" или "waves" (по умолчанию "zigzag")

---

### 7. Функция наложения эффекта бликов объектива камеры (`apply_lens_flare`)

**Алгоритм реализации:**

Эффект бликов имитирует отражение света в объективе камеры.

1. Получаем размеры изображения.
2. Создаем маску бликов (массив нулей размером изображения).
3. Определяем позиции источников света (несколько точек на изображении, например, четверти и центр).
4. Для каждого источника света:
   - Создаем координатные сетки.
   - Вычисляем расстояние от каждого пикселя до источника света: `sqrt((X - center_x)² + (Y - center_y)²)`.
   - Создаем гауссово распределение для блика: `exp(-(dist²) / (radius² / 4))` - чем дальше от центра, тем слабее эффект.
   - Добавляем силу блика к общей маске.
5. Нормализуем маску и применяем параметр интенсивности: `clip(mask, 0, 1) * intensity`.
6. Создаем эффект блика (белый цвет): массив единиц, умноженный на 255.
7. Смешиваем исходное изображение с эффектом блика:
   - `result = image * (1 - flare_mask) + flare_effect * flare_mask`
   - В областях с бликами изображение становится светлее (ближе к белому).
8. Ограничиваем значения диапазоном [0, 255] и преобразуем в `uint8`.

**Параметры:**
- `image` - исходное изображение
- `intensity` - интенсивность эффекта (по умолчанию 0.3)

---

### 8. Функция наложения текстуры акварельной бумаги (`apply_watercolor_texture`)

**Алгоритм реализации:**

Эффект создает текстуру акварельной бумаги, имитируя неровности поверхности.

1. **Создание текстуры** (`create_watercolor_texture`):
   - Создаем пустую текстуру размером изображения.
   - Генерируем сложную текстуру путем наложения нескольких синусоидальных волн с разными частотами (0.005, 0.02, 0.1).
   - Для каждой частоты вычисляем значение: `sin(x * freq) * sin(y * freq) * 0.2`.
   - Суммируем все частотные компоненты.
   - Нормализуем текстуру к диапазону [0, 1]: `(texture - min) / (max - min)`.

2. **Применение текстуры** (`apply_watercolor_texture`):
   - Создаем текстуру бумаги для размеров изображения.
   - Преобразуем текстуру в фактор затемнения/осветления: `0.7 + paper_texture * 0.6` (диапазон [0.7, 1.3]).
   - Применяем текстуру к изображению: `image * texture_effect` - создает вариации яркости.
   - Смешиваем результат с оригиналом с учетом интенсивности:
     - `result = original * (1 - intensity) + textured * intensity`
   - Ограничиваем значения диапазоном [0, 255] и преобразуем в `uint8`.

**Параметры:**
- `image` - исходное изображение
- `texture_intensity` - интенсивность наложения текстуры (по умолчанию 0.3)

---

## Использование

### Запуск демонстрации всех фильтров:
```bash
python main.py
```

### Применение конкретного фильтра:
```bash
python main.py <путь_к_изображению> --filter <тип_фильтра> [параметры]
```

### Примеры использования:

**Изменение разрешения:**
```bash
python main.py photo.jpg --filter resize --width 400
```

**Эффект сепии:**
```bash
python main.py photo.jpg --filter sepia
```

**Виньетка:**
```bash
python main.py photo.jpg --filter vignette --strength 0.6
```

**Пикселизация:**
```bash
python main.py photo.jpg --filter pixelate
```

**Одноцветная рамка:**
```bash
python main.py photo.jpg --filter solid_border --border_width 15 --border_color 0 0 255
```

**Фигурная рамка:**
```bash
python main.py photo.jpg --filter patterned_border --border_width 25 --border_color 0 255 0 --pattern zigzag
```

**Блики объектива:**
```bash
python main.py photo.jpg --filter lens_flare --intensity 0.2
```

**Акварельная текстура:**
```bash
python main.py photo.jpg --filter watercolor --intensity 0.4
```

---
