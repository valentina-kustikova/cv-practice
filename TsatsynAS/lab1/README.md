# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание

Данная работа представляет собой библиотеку фильтров для обработки изображений, реализованную с использованием базовых операций над матрицами в OpenCV. Все функции реализованы без использования высокоуровневых функций обработки изображений библиотеки OpenCV.

## Реализованные функции

### 1. Функция изменения разрешения изображения (`change_resolution`)

**Алгоритм реализации:**

Функция изменяет разрешение изображения путем масштабирования с использованием индексации массивов NumPy.

1. Получаем текущие размеры изображения (высота и ширина).
2. Вычисляем новые размеры на основе переданных параметров:
   - Если задана только ширина, высота вычисляется пропорционально.
   - Если задана только высота, ширина вычисляется пропорционально.
   - Если заданы оба параметра, используются они.
3. Создаем массивы индексов для нового изображения:
   - Для каждого пикселя нового изображения вычисляется соответствующий пиксель исходного изображения по формуле: `индекс_нового * (размер_старого / размер_нового)`.
4. Используем индексацию массивов NumPy для выборки пикселей из исходного изображения: `image[y_indices[:, None], x_indices[None, :]]`.
5. Ограничиваем индексы диапазоном допустимых значений с помощью `np.clip`.

**Параметры:**
- `image` - исходное изображение
- `new_width` - новая ширина (опционально)
- `new_height` - новая высота (опционально)

---

### 2. Функция применения фотоэффекта сепии (`apply_sepia`)

**Алгоритм реализации:**

Эффект сепии достигается путем применения цветовой матрицы преобразования к каждому пикселю изображения.

1. Определяем матрицу преобразования сепии (3x3), которая задает веса для каналов RGB:
   ```
   [[0.393, 0.769, 0.189],
    [0.349, 0.686, 0.168],
    [0.272, 0.534, 0.131]]
   ```
2. Преобразуем изображение в тип `float` для точных вычислений.
3. Применяем матричное умножение: `np.dot(image, sepia_filter.T)` - умножаем каждый пиксель на транспонированную матрицу фильтра.
4. Ограничиваем значения результата диапазоном [0, 255] с помощью `np.clip`.
5. Преобразуем результат обратно в тип `uint8`.

**Параметры:**
- `image` - исходное изображение

---

### 3. Функция применения фотоэффекта виньетки (`apply_vignette`)

**Алгоритм реализации:**

Виньетка создает эффект затемнения по краям изображения, имитируя эффект объектива камеры.

1. Получаем размеры изображения (высота и ширина).
2. Создаем координатные сетки для всех пикселей с помощью `np.meshgrid`.
3. Вычисляем центр изображения: `(width // 2, height // 2)`.
4. Для каждого пикселя вычисляем расстояние до центра по формуле: `sqrt((X - center_x)² + (Y - center_y)²)`.
5. Вычисляем максимальное расстояние от центра до угла изображения.
6. Создаем фактор виньетки: `1 - (расстояние / максимальное_расстояние) * strength`.
   - В центре фактор близок к 1 (яркость сохраняется).
   - На краях фактор близок к 0 (затемнение).
7. Ограничиваем фактор диапазоном [0, 1].
8. Применяем фактор к каждому каналу изображения: `image * vignette_factor`.
9. Преобразуем результат обратно в тип `uint8`.

**Параметры:**
- `image` - исходное изображение
- `strength` - сила эффекта виньетки (по умолчанию 0.8)

---

### 4. Функция пикселизации заданной прямоугольной области изображения (`interactive_pixelation`)

**Алгоритм реализации:**

Пикселизация разбивает выбранную область на блоки и заменяет каждый блок средним цветом пикселей в этом блоке.

1. Создаем интерактивный интерфейс для выбора области:
   - Используется callback-функция для обработки событий мыши.
   - Пользователь перетаскивает мышь для выбора прямоугольной области.
2. После подтверждения выбора (клавиша SPACE):
   - Определяем границы выбранной области (минимальные и максимальные координаты).
   - Разбиваем область на блоки размером `pixel_size` (10 пикселей).
3. Для каждого блока:
   - Извлекаем пиксели блока из исходного изображения.
   - Вычисляем средний цвет блока по всем каналам: `np.mean(block, axis=(0, 1))`.
   - Заменяем все пиксели блока на вычисленный средний цвет.
4. Возвращаем изображение с пикселизированной областью.

**Параметры:**
- `image` - исходное изображение
- `pixel_size` - по умолчанию 10

---

### 5. Функция наложения прямоугольной одноцветной рамки (`add_solid_border`)

**Алгоритм реализации:**

Функция добавляет одноцветную рамку заданной ширины по краям изображения.

1. Получаем размеры исходного изображения.
2. Создаем новое изображение большего размера:
   - Новая высота: `height + 2 * border_width`
   - Новая ширина: `width + 2 * border_width`
3. Инициализируем новое изображение цветом рамки: заполняем весь массив значением `border_color`.
4. Копируем исходное изображение в центр нового изображения:
   - Позиция: `[border_width:border_width + height, border_width:border_width + width]`

**Параметры:**
- `image` - исходное изображение
- `border_width` - ширина рамки в пикселях (по умолчанию 10)
- `border_color` - цвет рамки в формате BGR (по умолчанию белый)

---

### 6. Функция наложения фигурной одноцветной рамки (`add_patterned_border`)

**Алгоритм реализации:**

Функция добавляет фигурную рамку с различными узорами по краям изображения.

1. Создаем изображение с увеличенными размерами (аналогично одноцветной рамке).
2. Копируем исходное изображение в центр.
3. Создаем координатные сетки для всего изображения с помощью `np.ogrid`.
4. Определяем маску границ: пиксели, которые находятся в области рамки (в пределах `border_width` от краев).
5. В зависимости от типа узора (`pattern_type`):
   - **"zigzag"**: Создаем зигзагообразный узор на основе условия `(X + Y) % 10 < 5` - чередование пикселей по диагонали.
   - **"dots"**: Создаем точечный узор на основе условия `(X % 10 == 0) & (Y % 10 == 0)` - точки на пересечении сетки.
   - **"waves"**: Создаем волнообразный узор на основе синусоидальной функции `(np.sin(X * 0.1) + np.sin(Y * 0.1)) > 0`.
6. Применяем узор только к области рамки: `bordered_image[mask & border_mask] = border_color`.

**Параметры:**
- `image` - исходное изображение
- `border_width` - ширина рамки в пикселях (по умолчанию 20)
- `border_color` - цвет рамки в формате BGR (по умолчанию белый)
- `pattern_type` - тип узора: "zigzag", "dots" или "waves" (по умолчанию "zigzag")

---

### 7. Функция наложения эффекта бликов объектива камеры (`apply_lens_flare`)

**Алгоритм реализации:**

Эффект бликов имитирует отражение света в объективе камеры.

1. Загрузка текстуры блика:
- Загружается изображение-текстура с эффектом блика из файла
- Если файл не найден, выводится предупреждение и используется прозрачная маска

2. Подготовка размеров:
- Текстура блика масштабируется под размер исходного изображения
- Обеспечивается точное соответствие размеров для корректного наложения

3. Альфа-смешивание:
- Исходное изображение и текстура блика конвертируются в вещественные числа
-  Смешиваем исходное изображение с эффектом блика:
   - `result = image * (1 - flare_mask) + flare_effect * flare_mask`
   - В областях с бликами изображение становится светлее (ближе к белому).
4. Нормализация результата:
- Значения ограничиваются диапазоном [0, 255]
- Результат конвертируется обратно в целочисленный формат

**Параметры:**
- `image` - исходное изображение
- `intensity` - интенсивность эффекта (по умолчанию 0.3)
- `flare_texture_path` - путь к файлу текстуры блика

---

### 8. Функция наложения текстуры акварельной бумаги (`apply_watercolor_texture`)

**Алгоритм реализации:**

Эффект создает текстуру акварельной бумаги, имитируя неровности поверхности.

1. **Создание текстуры**:
   - Загружается изображение текстуры акварельной бумаги
   - Текстура масштабируется под размер исходного изображения
   - При отсутствии файла выводится предупреждение

2. **Применение текстуры**:
- Текстура конвертируется в grayscale для получения информации о яркости
- Создается инвертированная маска: 1 - (brightness / 255)
- Темные области текстуры → высокие значения маски (близко к 1)
- Светлые области текстуры → низкие значения маски (близко к 0)
- Маска усиливается для более выраженного эффекта: mask ** (1/0.9)
- Добавляется третья размерность для совместимости с цветным изображением
- `result = image × (1 - mask × intensity) + paper_texture × (mask × intensity)`
- Ограничиваем значения диапазоном [0, 255] и преобразуем в `uint8`.

**Параметры:**
- `image` - исходное изображение
- `texture_intensity` - интенсивность наложения текстуры (по умолчанию 0.3)
- `paper_texture_path` - путь к файлу текстуры бумаги

---

## Использование

### Запуск демонстрации всех фильтров:
```bash
python main.py
```

### Применение конкретного фильтра:
```bash
python main.py <путь_к_изображению> --filter <тип_фильтра> [параметры]
```

### Примеры использования:

**Изменение разрешения:**
```bash
python main.py photo.jpg --filter resize --width 400
```

**Эффект сепии:**
```bash
python main.py photo.jpg --filter sepia
```

**Виньетка:**
```bash
python main.py photo.jpg --filter vignette --strength 0.6
```

**Пикселизация:**
```bash
python main.py photo.jpg --filter pixelate
```

**Одноцветная рамка:**
```bash
python main.py photo.jpg --filter solid_border --border_width 15 --border_color 0 0 255
```

**Фигурная рамка:**
```bash
python main.py photo.jpg --filter patterned_border --border_width 25 --border_color 0 255 0 --pattern zigzag
```

**Блики объектива:**
```bash
python main.py photo.jpg --filter lens_flare --intensity 0.2
```

**Акварельная текстура:**
```bash
python main.py photo.jpg --filter watercolor --intensity 0.4
```

---
