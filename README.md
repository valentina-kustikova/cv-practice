HEAD
# Практика по курсу "Основы компьютерного зрения"

## Требования к структуре директорий

Основная директория должна иметь название `FamiliaIO`. Внутри необходимо создать
3 вложенные директории в соответствии с номерами практических работ (`lab1`,
`lab2`, `lab3`)

## Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

**Задача.** Разработать библиотеку фильтров с помощью базовых операций
над изображениями (матрицами) в OpenCV:
- Функция изменения разрешения изображения.
- Функция применения фотоэффекта сепии к изображению.
- Функция применения фотоэффекта виньетки к изображению.
- Функция пикселизации заданной прямоугольной области изображения.
- Функция наложения прямоугольной одноцветной рамки заданной ширины по краям изображения.
- Функция наложения фигурной одноцветной рамки по краям изображения. Тип фигурной рамки
  является параметром функции.
- Функция наложения эффекта бликов объектива камеры.
- Функция наложения текстуры акварельной бумаги.

**Требования:**
- Язык разработки – Python, среда разработки – Spyder или любая другая.
- При реализации функций можно использовать только базовые операции над изображением,
  нельзя использовать высокоуровневые функции обработки изображений библиотеки OpenCV.
- Скрипт должен содержать набор функций в соответствии с перечнем из постановки задачи
  и демонстрировать их использование. Входные параметры скрипта: изображение для обработки,
  тип фильтра, параметры фильтра при наличии таковых. Последовательность работы скрипта включает
  загрузку исходного изображения, применение функции фильтрации, отображение исходного
  и отфильтрованного изображения.
- Скрипт должен сопровождаться файлом README.md, в котором дается описание
  алгоритма реализации каждого фильтра (мини-отчет).
- В шапке файла README.md необходимо указать название практической работы:
  "Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV".
- Результаты выполнения практической работы должны быть выложены в личный форк репозитория
  курса, из которого отправлен Pull Request в репозиторий курса. При этом директория
  практической работы должна содержать скрипт и файл README.md.

**Оценивание:**
- Наличие корректной реализации отдельной функции и ее демонстрации - 2 балла
  (максимум - 16 баллов).
- Наличие README - 4 балла.
- Максимальный балл за практическую работу - 20 баллов.

## Практическая работа №2. Детектирование объектов на изображениях с использованием библиотеки OpenCV

**Задача.** Разработать приложение для детектирования транспортных средств с использованием обученных
нейронных сетей, которые доступны среди "зоопарка" моделей OpenCV. При выборе моделей необходимо
обратить внимание на наличие интересующих классов транспортных средств среди детектируемых классов
объектов. Архив с кадрами видео доступен по [ссылке](https://cloud.unn.ru/s/nLkk7BXBqapNgcE), разметка
в текстовом формате доступна по [ссылке](https://cloud.unn.ru/s/j4wA4nx8mZ4yfqD).

**Требования:**
- Язык разработки – Python, среда разработки – Spyder или любая другая.
- При реализации необходимо использовать модуль DNN библиотеки OpenCV.
- Разрабатываемая библиотека должна содержать иерархию классов для детектирования объектов с использованием
  различных моделей. Необходимо предусмотреть, что использование моделей предполагает применение разных методов
  предобработки изображений, а также методов постобработки выхода моделей.
- Демонстрационное приложение должно загружать последовательность кадров видео, создавать детектор в соответствии
  с выбором модели, опционально отображать кадры видео, на которых отрисованы прямоугольниками разных
  цветов объекты разных классов (цвет соответствует классу объектов), и выводить показатели качества детектирования TPR и FDR.
  При отображении в левом верхнем	углу каждого прямоугольника необходимо написать название класса и достоверность наличия
  объекта в этом прямоугольнике	(точность для отображения вещественного числа – три знака после запятой), над прямоугольником
  необходимо указать наблюдаемый класс объектов. Путь до набора изображений и модель для детектирования объектов
  являются параметрами приложения.
- Программное решение должно сопровождаться файлом README.md, в котором для каждой выбранной модели дается описание
  реализованных алгоритмов предварительной обработки изображений и обработки выхода сети (мини-отчет).
- В шапке файла README.md необходимо указать название практической работы: "Практическая работа №2.
  Детектирование объектов на изображениях с использованием библиотеки OpenCV".
- Результаты выполнения практической работы должны быть выложены в репозиторий курса. При этом
  директория практической работы содержит набор разработанных скриптов и файл README.md.

**Оценивание:**
- Наличие возможности использования одной модели - 5 баллов.
- Наибольшее количество моделей - 3 модели.
- Наличие корректного приложения - 5 баллов.
- Наличие README - 5 баллов.
- Дополнительный балл за качество работы модели - 10 * TPR баллов.
- Максимальный балл за практическую работу - 35 баллов.

## Практическая работа №3. Классификация изображений с использованием библиотеки OpenCV

**Задача.** Разработать приложение для классификации изображений известных достопримечательностей
Нижнего Новгорода (Нижегородский Кремль, Дворец труда, Архангельский собор). Набор данных
доступен по [ссылке](https://cloud.unn.ru/s/2KsWFmaxzZf9mF5), он содержит фотографии студентов
ИИТММ (директория `NNSUDataset`) и  фотографии, выгруженные из сети Интернет (директория `ExtDataset`).
Директория со сторонними фотографиями также сопровождается текстовым файлом с перечнем ссылок на источники.
Перечень изображений тренировочной выборки доступен по [ссылке](https://cloud.unn.ru/s/5rakAsHxweBi6qD),
остальные изображения попадают в тестовую выборку. Приложение должно реализовывать алгоритм
"мешок слов" и/или использовать нейросетевые классификаторы.

Входные параметры приложения:
- Путь до директории с данными.
- Файлы разбиения на тренировочную и тестовую выборки.
- Режим работы (обучение и/или тестирование).
- Алгоритм работы ("мешок слов"/нейронная сеть).
- Параметры алгоритма работы.

Последовательность работы приложения:
- Загрузка набора данных.
-	Обучение и/или тестирование классификатора. В процессе тестирования необходимо выводить качество решения
  задачи классификации на тестовой выборке.

Рекомендации и комментарии к выполнению работы:
1. При разработке программного кода необходимо учитывать основы модульного и объектно-ориентированного
 	 подходов.
1. Для повышения качества решения задачи необходимо расширить тренировочный набор данных собственными
   изображениями или фотографиями интересующих объектов из сети Интернет.
1. При реализации алгоритма "мешок слов" необходимо исследовать возможности разных детекторов
   и дескрипторов.
1. Для удобства проверки алгоритма "мешок слов" имеет смысл визуализировать отдельные этапы.
1. Выбор метода машинного обучения для построения классификатора при реализации алгоритма "мешок слов"
   не ограничен.
1. При построении нейронных сетей для классификации имеет смысл опираться на идеи "переноса обучения"
   существующих классификационных моделей дообучать эти модели, поскольку тренировочная выборка имеет
   небольшие размеры.

**Требования:**
-	Язык разработки – Python, среда разработки – Spyder или любая другая.
- Программное решение должно сопровождаться файлом README.md, в котором дается описание
  реализованных алгоритмов (мини-отчет).
-	В шапке файла README.md необходимо указать название практической работы:
  "Практическая работа №3. Классификация изображений с использованием библиотеки OpenCV".
-	Результаты выполнения практической работы должны быть выложены в репозиторий курса. При этом
  директория практической работы содержит скрипт и файл README.md.
- Набор из дополнительных фото должен быть выложен в открытый доступ. Если используются сторонние
  фотографии (или ваши опубликованные где-то в сети), то необходимо рядом с набором положить текстовый файл
  с ссылками на источники по аналогии с входным набором данных.

**Оценивание:**
- Наличие разработанной программной реализации алгоритма "мешок слов" - 10 баллов.
- Наличие реализации процедуры обучения и использования сети - 15 баллов.
- Наличие README - 5 баллов.
- Дополнительный балл за качество работы модели - 10 * accuracy баллов (accuracy - точность классификации).
- Максимальный балл за практическую работу - 40 баллов (при наличии реализации алгоритма "мешок слов"
  и обучения нейросетевой модели).

## Отчетность по курсу

Отчетность по курсу - зачет. Для получения "зачета" необходимо в процессе сдачи лабораторных работ набрать
**не менее 75 баллов**.
=======
# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание

В рамках практической работы разработана библиотека фильтров для обработки изображений с использованием **только базовых операций над матрицами** (без высокоуровневых функций OpenCV). Все реализованные эффекты построены на основе `numpy` и ручной обработки пикселей. Проект включает в себя как демонстрацию фильтров в среде **Google Colab**, так и отдельный локальный инструмент для интерактивной пикселизации через выбор области мышью.

---

## Реализованные функции

### 1. Функция изменения разрешения изображения (`resize_image`)
**Алгоритм:**  
Реализован метод ресемплинга "ближайшего соседа" вручную через пересчёт координат. Для каждого пикселя в выходном изображении вычисляется соответствующий пиксель во входном изображении с помощью линейного отображения координат. Используются базовые циклы и индексация массивов.

**Параметры:**  
- `image` — исходное изображение  
- `width` — новая ширина (опционально)  
- `height` — новая высота (опционально)

---

### 2. Функция применения фотоэффекта сепии (`apply_sepia`)
**Алгоритм:**  
Применяется матрица линейного преобразования цветов, имитирующая старинный сепийный оттенок. Каждый пиксель умножается на фиксированную матрицу 3×3. Результат ограничивается диапазоном [0, 255] с помощью `np.clip`.

**Матрица преобразования:**

[0.272, 0.534, 0.131]
[0.349, 0.686, 0.168]
[0.393, 0.769, 0.189]


**Параметры:**  
- `image` — исходное изображение

---

### 3. Функция применения фотоэффекта виньетки (`apply_vignette`)
**Алгоритм:**  
Вычисляется центр изображения, затем для каждого пикселя рассчитывается евклидово расстояние до центра. На основе этого расстояния формируется маска затемнения по краям. Маска применяется поэлементно к каждому цветовому каналу.

**Параметры:**  
- `image` — исходное изображение  
- `strength` — сила эффекта (0.0–1.0, по умолчанию 0.6)

---

### 4. Функция пикселизации заданной прямоугольной области (`pixelize_region`)
**Алгоритм:**  
Выделенная прямоугольная область разбивается на блоки размером `pixel_size × pixel_size`. Каждый блок заменяется на сплошной цвет, равный среднему значению пикселей в блоке. Усреднение выполняется по всем трём каналам.

**Параметры:**  
- `image` — исходное изображение  
- `x`, `y` — координаты левого верхнего угла области  
- `width`, `height` — размеры области  
- `pixel_size` — размер пикселя для пикселизации (по умолчанию 10)

---

### 5. Функция наложения прямоугольной одноцветной рамки (`apply_solid_border`)
**Алгоритм:**  
Создаётся новое изображение с увеличенными размерами. Исходное изображение вставляется в центр, а края заполняются заданным цветом с помощью срезов массивов.

**Параметры:**  
- `image` — исходное изображение  
- `border_width` — ширина рамки  
- `color` — цвет рамки в формате BGR (по умолчанию белый)

---

### 6. Функция наложения фигурной одноцветной рамки (`apply_custom_border`)
**Алгоритм:**  
Реализована штриховая (dashed) рамка: по всем четырём сторонам изображения рисуются чередующиеся цветные и прозрачные сегменты заданной длины. Используется только присваивание значений срезам массива.

**Параметры:**  
- `image` — исходное изображение  
- `border_width` — ширина рамки  
- `border_type` — тип рамки (поддерживается только `'dashed'`)  
- `color` — цвет рамки в формате BGR

---

### 7. Функция наложения эффекта бликов объектива (`apply_lens_flare`)
**Алгоритм:**  
Загружается внешняя PNG-текстура блика с альфа-каналом. Текстура масштабируется под изображение и накладывается в указанной позиции с использованием альфа-смешивания:  
`результат = изображение × (1 - α) + текстура × α`

**Параметры:**  
- `image` — исходное изображение  
- `flare_path` — путь к PNG-файлу с бликом  
- `flare_position` — координаты центра блика (по умолчанию (100, 100))

---

### 8. Функция наложения текстуры акварельной бумаги (`apply_watercolor_texture`)
**Алгоритм:**  
Загружается внешняя PNG-текстура акварельной бумаги с альфа-каналом. Текстура масштабируется под размер изображения и накладывается с учётом прозрачности. Для изображений без альфа-канала используется умножение каналов.

**Параметры:**  
- `image` — исходное изображение  
- `texture_path` — путь к PNG/JPG-файлу с текстурой

---

## Особенности реализации

### Google Colab
Все фильтры (1–8) реализованы и протестированы в среде **Google Colab**. Для демонстрации используется `matplotlib` вместо `cv2.imshow`, так как Colab не поддерживает GUI-окна OpenCV. Текстуры для блика и акварели генерируются программно непосредственно в ноутбуке, что исключает необходимость ручной загрузки файлов.

### Интерактивная пикселизация (локально)
Функция пикселизации также реализована в виде **отдельного локального скрипта `pixelize_tool.py`**, который:
- Открывает изображение в окне OpenCV
- Позволяет выделить область с помощью мыши (через `cv2.setMouseCallback`)
- Применяет пикселизацию по завершении выделения
- Работает только при локальном запуске (не в Colab)

Это сделано потому, что **Google Colab не поддерживает интерактивные окна OpenCV с обработкой событий мыши**.

---

## Структура проекта

---

## Использование

### В Google Colab
1. Загрузите изображение
2. Выполните ячейку с `filters.py`
3. Примените любой фильтр к изображению
4. Результат будет отображён через `matplotlib`

### Локально (для пикселизации)
```bash
pip install opencv-python numpy
python pixelize_tool.py ваше_изображение.jpg
 4e7f8b9 (lab1: реализация фильтров и интерактивной пикселизации)
