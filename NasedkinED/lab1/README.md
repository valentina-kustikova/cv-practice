# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание

В данной работе реализована библиотека фильтров для обработки изображений с использованием **Python** и **NumPy**.

## Алгоритмы реализации фильтров

### 1. Функция изменения разрешения изображения (`resize_image`)

**Алгоритм:** Реализован метод ближайшего соседа (Nearest Neighbor).
Используются функции `np.linspace` для генерации массивов индексов координат по новой сетке. Результирующее изображение
формируется путем выборки пикселей из исходного изображения по этим индексам с использованием "Fancy Indexing"
библиотеки NumPy.

### 2. Функция применения фотоэффекта сепии (`apply_sepia`)

**Алгоритм:** Матричное преобразование цветов.
Исходное изображение рассматривается как трехмерная матрица. Производится скалярное произведение (dot product) матрицы
изображения и матрицы коэффициентов сепии.
Коэффициенты (для BGR):

- B_new = 0.272R + 0.534G + 0.131B
- G_new = 0.349R + 0.686G + 0.168B
- R_new = 0.393R + 0.769G + 0.189B
  Результат ограничивается диапазоном [0, 255].

### 3. Функция применения фотоэффекта виньетки (`apply_vignette`)

**Алгоритм:** Радиальный градиент.
С помощью `np.ogrid` создаются координатные сетки `X` и `Y`. Рассчитывается матрица расстояний каждого пикселя от центра
изображения.
Матрица затемнения вычисляется по формуле: $factor = 1 - strength \times dist^2$.
Эта матрица перемножается с исходным изображением (broadcasting).

### 4. Функция пикселизации заданной области (`pixelate_region`)

**Алгоритм:**

1. Пользователь выбирает прямоугольную область мышью (Callback-функция OpenCV).
2. Из области интереса (ROI) выбирается каждый N-й пиксель (слайсинг с шагом `::pixel_size`), что эффективно уменьшает
   разрешение области.
3. Полученная уменьшенная матрица "растягивается" обратно до исходных размеров с помощью `np.repeat` (повторение
   элементов массива), создавая эффект крупных квадратных пикселей.

### 5. Функция наложения прямоугольной одноцветной рамки (`add_rect_border`)

**Алгоритм:** Использование срезов (slicing).
Копируется исходное изображение. Верхним, нижним, левым и правым полосам массива присваивается заданный цвет (например,
`bordered[0:width, :] = color`).

### 6. Функция наложения фигурной одноцветной рамки (`add_shaped_border`)

**Алгоритм:** Использование логических масок.

- **Волна (`wave`):** Создаются векторы смещений на основе функции синуса от координат. Формируются булевы маски, где
  координата пикселя меньше смещения (для волнистого края).
- **Точки (`dots`):** Используется остаток от деления координат на шаг решетки (`coord % spacing`) для создания
  периодической маски.
  Цвет применяется к пикселям, попавшим в маску `True`.

### 7. Функция наложения эффекта бликов (`add_lens_flare`)

**Алгоритм:** Наложение текстуры.
Загружается изображение блика (`glare.jpg`). Оно масштабируется под размер целевого изображения с помощью собственной
функции `resize_image`.
Блик накладывается аддитивно (сложение яркостей) или через альфа-смешивание, создавая эффект свечения линзы.

### 8. Функция наложения текстуры акварельной бумаги (`add_watercolor_texture`)

**Алгоритм:** Взвешенная сумма.
Загружается текстура бумаги (`watercolor_texture.jpg`), масштабируется.
Итоговое изображение вычисляется как: $Result = Image \times (1 - \alpha) + Texture \times \alpha$.