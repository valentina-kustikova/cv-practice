# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV

## Описание проекта

Библиотека фильтров для обработки изображений, разработанная с использованием базовых операций над изображениями (матрицами) в OpenCV. Проект включает 8 различных фильтров с возможностью интерактивного применения.

## Установка и запуск

### Требования
- Python 3.x
- OpenCV (`opencv-python`)
- NumPy

### Установка зависимостей
```bash
pip install opencv-python numpy
```

### Запуск программы

Общий формат команды:
```bash
python main.py <путь_к_изображению> <тип_фильтра> [параметры]
```

## Описание фильтров и их использование

### 1. Изменение разрешения изображения (`resize`)

**Алгоритм:**
Функция изменяет разрешение изображения с использованием билинейной интерполяции, реализованной вручную.

**Принцип работы:**
1. Вычисляются новые размеры изображения на основе заданных параметров (ширина, высота или коэффициент масштабирования)
2. Создается новая матрица результирующего изображения
3. Для каждого пикселя нового изображения:
   - Вычисляются соответствующие дробные координаты в исходном изображении
   - Находятся 4 ближайших пикселя
   - Выполняется билинейная интерполяция для каждого канала цвета
   - Формула: `I(x,y) = (1-dx)(1-dy)I₁ + dx(1-dy)I₂ + (1-dx)dy×I₃ + dx×dy×I₄`

**Примеры использования:**
```bash
# Масштабирование в 0.5 раза
python main.py image.jpg resize --scale 0.5

# Изменение до конкретных размеров
python main.py image.jpg resize --width 800 --height 600

# Изменение только ширины (высота вычисляется автоматически)
python main.py image.jpg resize --width 1024
```

---

### 2. Фотоэффект сепии (`sepia`)

**Алгоритм:**
Применяет к изображению теплый коричневый оттенок, характерный для старых фотографий.

**Принцип работы:**
1. Для каждого пикселя изображения применяется матрица преобразования цветов
2. Формулы преобразования (для RGB):
   - `R_new = R × 0.393 + G × 0.769 + B × 0.189`
   - `G_new = R × 0.349 + G × 0.686 + B × 0.168`
   - `B_new = R × 0.272 + G × 0.534 + B × 0.131`
3. Результат смешивается с оригинальным изображением согласно параметру интенсивности
4. Значения обрезаются до диапазона [0, 255]

**Примеры использования:**
```bash
# Полная интенсивность сепии
python main.py image.jpg sepia --intensity 1.0

# Частичный эффект (50%)
python main.py image.jpg sepia --intensity 0.5
```

---

### 3. Фотоэффект виньетки (`vignette`)

**Алгоритм:**
Затемняет края изображения, создавая эффект старинной фотографии или акцентируя внимание на центре.

**Принцип работы:**
1. Определяется центр изображения
2. Вычисляется максимальное расстояние от центра до угла
3. Для каждого пикселя:
   - Вычисляется расстояние от центра: `d = √((x-cx)² + (y-cy)²)`
   - Нормализуется расстояние: `d_norm = d / d_max`
   - Вычисляется коэффициент затемнения: `factor = 1 - (d_norm × intensity)`
   - Пиксель умножается на коэффициент: `I_new = I × factor`

**Примеры использования:**
```bash
# Средняя интенсивность виньетки
python main.py image.jpg vignette --intensity 0.5

# Сильная виньетка
python main.py image.jpg vignette --intensity 0.8
```

---

### 4. Пикселизация области (`pixelate`)

**Алгоритм:**
Создает эффект пикселизации (мозаики) в выбранной пользователем прямоугольной области.

**Принцип работы:**
1. Программа запускается в интерактивном режиме
2. Пользователь выделяет прямоугольную область мышью (нажать, протянуть, отпустить)
3. Выделенная область разбивается на блоки размером `pixel_size × pixel_size`
4. Для каждого блока:
   - Вычисляется средний цвет всех пикселей: `C_avg = (1/n)∑C_i`
   - Все пиксели блока заменяются средним цветом
5. Можно выделять несколько областей подряд

**Примеры использования:**
```bash
# Пикселизация с размером блока 10 пикселей
python main.py image.jpg pixelate --pixel-size 10

# Крупная пикселизация (20 пикселей)
python main.py image.jpg pixelate --pixel-size 20

# Мелкая пикселизация (5 пикселей)
python main.py image.jpg pixelate --pixel-size 5
```

---

### 5. Прямоугольная рамка (`simple_frame`)

**Алгоритм:**
Накладывает одноцветную прямоугольную рамку заданной ширины по краям изображения.

**Принцип работы:**
1. Определяются четыре прямоугольные области по краям изображения
2. Все пиксели в этих областях заменяются на заданный цвет:
   - Верхняя рамка: `[0:frame_width, :]`
   - Нижняя рамка: `[h-frame_width:h, :]`
   - Левая рамка: `[:, 0:frame_width]`
   - Правая рамка: `[:, w-frame_width:w]`

**Примеры использования:**
```bash
# Черная рамка шириной 20 пикселей
python main.py image.jpg simple_frame --frame-width 20

# Белая рамка (BGR: 255 255 255)
python main.py image.jpg simple_frame --frame-width 30 --color 255 255 255

# Золотая рамка (BGR: 0 215 255)
python main.py image.jpg simple_frame --frame-width 25 --color 0 215 255
```

---

### 6. Фигурная рамка (`decorative_frame`)

**Алгоритм:**
Создает декоративную рамку с различными стилями: скругленные углы, волны или зигзаг.

**Принцип работы:**

**Стиль "rounded" (скругленные углы):**
1. Для углов проверяется условие: `(x-cx)² + (y-cy)² > r²`
2. Если точка находится за пределами круга радиусом `r` в углу, она окрашивается
3. Остальные края остаются прямыми

**Стиль "wave" (волны):**
1. Граница рамки вычисляется по синусоидальной функции
2. Формула: `border(x) = amplitude × sin(x × frequency) + frame_width`
3. Создает плавные волнообразные края

**Стиль "zigzag" (зигзаг):**
1. Граница рамки меняется ступенчато
2. Использует модульную арифметику: `(i // size) % 2 × size`
3. Создает зубчатые края

**Примеры использования:**
```bash
# Рамка со скругленными углами
python main.py image.jpg decorative_frame --frame-style rounded --frame-width 30

# Волнообразная рамка
python main.py image.jpg decorative_frame --frame-style wave --frame-width 25

# Зигзагообразная рамка с красным цветом (BGR: 0 0 255)
python main.py image.jpg decorative_frame --frame-style zigzag --frame-width 20 --color 0 0 255
```

---

### 7. Блики объектива (`lens_flare`)

**Алгоритм:**
Имитирует эффект бликов от линз камеры, характерный для фотографий с ярким источником света.

**Принцип работы:**
1. Определяется центр основного блика (по умолчанию или задан пользователем)
2. Создается основной яркий блик:
   - Для каждого пикселя вычисляется расстояние до центра
   - Интенсивность блика: `I = (1 - d/r) × intensity × 200`
   - Добавляется к значению пикселя с ограничением до 255
3. Создаются дополнительные цветные артефакты (обычно 3):
   - Располагаются на линии от центра к центру изображения
   - Каждый артефакт имеет свой цветовой канал
   - Размер артефактов уменьшается с расстоянием от основного блика

**Примеры использования:**
```bash
# Автоматическое размещение блика
python main.py image.jpg lens_flare --intensity 0.8

# Блик в конкретной точке
python main.py image.jpg lens_flare --center-x 500 --center-y 300 --intensity 1.0

# Слабый блик
python main.py image.jpg lens_flare --intensity 0.5
```

---

### 8. Текстура акварельной бумаги (`watercolor`)

**Алгоритм:**
Накладывает процедурную текстуру, имитирующую неровности акварельной бумаги.

**Принцип работы:**
1. Генерируется двухслойная текстура:
   - **Мелкозернистый слой**: блоки 2×2 пикселя с случайным шумом [-30, 30]
   - **Крупнозернистый слой**: блоки 10×10 пикселей с шумом [-20, 20], имитирующие волокна бумаги
2. Слои суммируются для создания сложной текстуры
3. Текстура применяется к изображению:
   - Для каждого пикселя: `I_new = clip(I + texture × intensity, 0, 255)`
4. Используется фиксированный seed для воспроизводимости результата

**Примеры использования:**
```bash
# Средняя интенсивность текстуры
python main.py image.jpg watercolor --intensity 0.3

# Сильная текстура
python main.py image.jpg watercolor --intensity 0.5

# Едва заметная текстура
python main.py image.jpg watercolor --intensity 0.1
```

---

## Особенности реализации

### Ограничения
В соответствии с требованиями задания, при реализации использовались **только базовые операции** над изображениями:
- Индексация массивов NumPy
- Арифметические операции
- Векторные и матричные операции для обработки пикселей
- Базовые математические функции (sqrt, sin, random)

**Не использовались:**
- Высокоуровневые функции OpenCV для обработки (фильтры, трансформации и т.д.)
- Готовые функции интерполяции, морфологии и др.

### Архитектура

Программа состоит из трех основных частей:

1. **Функции фильтров** - независимые функции, реализующие логику каждого фильтра
2. **Класс ImageFilterApp** - управляет интерфейсом и взаимодействием с пользователем
3. **Парсер аргументов командной строки** - обрабатывает входные параметры

### Интерактивность

- **Пикселизация**: интерактивный режим с выделением областей мышью
- **Остальные фильтры**: отображение оригинала и результата рядом для сравнения

## Примеры результатов

Для демонстрации работы всех фильтров:

```bash
# Подготовка тестового изображения
# (поместите изображение test.jpg в директорию с программой)

# Тестирование всех фильтров
python main.py test.jpg resize --scale 0.75
python main.py test.jpg sepia --intensity 0.8
python main.py test.jpg vignette --intensity 0.6
python main.py test.jpg pixelate --pixel-size 15
python main.py test.jpg simple_frame --frame-width 25 --color 128 64 0
python main.py test.jpg decorative_frame --frame-style wave --frame-width 30
python main.py test.jpg lens_flare --intensity 0.7
python main.py test.jpg watercolor --intensity 0.4
```

## Быстрая демонстрация всех фильтров

Для автоматического применения всех фильтров и сохранения результатов используйте скрипт `demo_filters.py`:

```bash
python demo_filters.py test_image.jpg
```

Этот скрипт:
- Применит все 10 фильтров + 2 комбинированных эффекта
- Сохранит результаты в папку `filter_results/`
- Отобразит сетку со всеми результатами для сравнения

