# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV
---

## 1. Функция `_resize_image(img, width, height, scale)`

**Назначение:**  
Масштабирует изображение

**Аргументы:**

- `img` — исходное изображение
- `width`, `height` — новая ширина и высота в пикселях
- `scale` — коэффициент масштабирования (вместо указания размеров)

**Алгоритм работы:**

1. Если задан `scale`, размеры пересчитываются пропорционально.
2. Если указаны `width` и/или `height`, подставляются заданные значения.
3. Формируются индексы пикселей `x_idx` и `y_idx` с помощью `np.arange` и целочисленного деления
4. Новый массив создаётся выборкой строк и столбцов через `np.take`

---

## 2. Функция `_sepia_filter(image, intensity)`

**Назначение:**  
Применяет эффект сепии

**Аргументы:**

- `image` — исходное изображение (BGR);
- `intensity` — степень проявления эффекта (от 0 до 1)

**Алгоритм работы:**

1. Создаётся матрица `sepia_matrix` (трансформация цветовых каналов).
2. Рассчитывается итоговая матрица `M` как комбинация единичной и сепийной.
3. Каждая строка пикселей умножается на транспонированную матрицу `M.T`.
4. Результат обрезается в диапазон `[0,255]` и преобразуется в `uint8`.

---

## 3. Функция `_vignette_filter(image, strength, radius)`

**Назначение:**  
Добавляет виньетку — затемнение по краям кадра

**Аргументы:**

- `strength` — сила затемнения (0–1)
- `radius` — радиус яркой центральной зоны (0–1)

**Алгоритм работы:**

1. Создаётся сетка координат (`X`, `Y`) с помощью `np.meshgrid`
2. Для каждого пикселя вычисляется его нормализованное расстояние от центра `r`
3. Строится маска затемнения: пиксели за радиусом затемняются сильнее
4. Маска расширяется до 3 каналов и применяется к изображению

---

## 4. Функция `_pixelate_region(image, x, y, w, h, block)`

**Назначение:**  
Пикселизирует заданную прямоугольную область изображения

**Аргументы:**

- `x, y` — координаты левого верхнего угла области
- `w, h` — ширина и высота области
- `block` — размер блока пикселизации

**Алгоритм работы:**

1. Вычисляется область интереса (ROI)
2. ROI уменьшается с помощью `_resize_image` до грубых размеров (`w/block`, `h/block`)
3. ROI увеличивается обратно — создаются крупные квадраты
4. Изменённая область вставляется обратно в исходное изображение

---

## 5. Функция `_add_simple_border(image, border, color)`

**Назначение:**  
Добавляет простую одноцветную рамку по краям изображения

**Аргументы:**

- `border` — толщина рамки в пикселях
- `color` — цвет рамки

**Алгоритм работы:**

1. Проверяется, что рамка положительной ширины
2. Верхняя, нижняя, левая и правая полосы заполняются цветом
3. Возвращается изображение с рамкой

---

## 6. Функция `_add_border(image, border_id, borders_dir, opacity)`

**Назначение:**  
Накладывает декоративную рамку из PNG-файла с альфа-каналом

**Аргументы:**

- `border_id` — номер рамки (`border1.png`, `border2.png`, `border3.png`);
- `borders_dir` — папка, где хранятся рамки
- `opacity` — прозрачность рамки (0–1)

**Алгоритм работы:**

1. Загружается PNG с прозрачностью (`cv2.IMREAD_UNCHANGED`)
2. При необходимости подгоняется размер к изображению
3. Разделяются RGB и альфа-канал
4. Альфа умножается на `opacity` и используется как маска
5. Итоговая картинка — линейная смесь рамки и исходного изображения

---

## 7. Функция `_add_flare(image, flares_dir, opacity, scale)`

**Назначение:**  
Добавляет эффект **блика объектива** (lens flare) поверх изображения.

**Аргументы:**

- `flares_dir` — папка, содержащая файл `flare.jpg` (с чёрным фоном)
- `opacity` — сила блика (0–1)
- `scale` — масштаб блика относительно кадра

**Алгоритм работы:**

1. Загружается изображение блика
2. Масштабируется по параметру `scale`
3. Центрируется относительно основного изображения
4. Комбинируется

---

## 8. Функция `_add_paper(image, paper_path, strength)`

**Назначение:**  
Создаёт эффект текстуры акварельной бумаги

**Аргументы:**

- `paper_path` — путь к файлу текстуры (`paper.jpg`)
- `strength` — сила проявления фактуры

**Алгоритм работы:**

1. Загружается и масштабируется изображение текстуры
2. Формируется маска — инверсия текстуры, усиленная `strength`
3. Применяется значение силы текстуры, которое влияет на контрастность будущего изображения (чем выше сила — тем
   выше контрастность), затем происходит смешивание исходного изображения и текстуры с поправкой на интенсивность
   накладываемого эффекта (по рассчитанной маске)

